import{_ as a,p as i,q as e,a1 as r}from"./framework-d81ad7e5.js";const l={},h=r('<p><strong>mysql</strong>中，我们可以使用begin开始事务，rollback回滚事务，commit提交事务</p><p>redolog 记录变更、undolog回滚</p><p>Spring中，使用@Transaction标记事务</p><h4 id="原子性-atomic" tabindex="-1"><a class="header-anchor" href="#原子性-atomic" aria-hidden="true">#</a> 原子性（Atomic）</h4><p>要么全部成功，要么全部失败，没有中间状态</p><h4 id="一致性-consistency" tabindex="-1"><a class="header-anchor" href="#一致性-consistency" aria-hidden="true">#</a> 一致性（Consistency）</h4><p>指的是在执行事务前后，事务外访问数据的时候，数据是一致的，要么看到的是成功的，要么看到的是失败的结果，不会多任务查询到的数据不一样。</p><h4 id="隔离性-isolation" tabindex="-1"><a class="header-anchor" href="#隔离性-isolation" aria-hidden="true">#</a> 隔离性（Isolation）</h4><p>一个事务在未完成时，另一个事务不会影响到他</p><h4 id="持久性-durability" tabindex="-1"><a class="header-anchor" href="#持久性-durability" aria-hidden="true">#</a> 持久性（Durability）</h4><p>会有持久化效果，改变是永久的</p><p>随着系统越来越庞大，我们为了提高可用性、维护性、吞吐量等等技术指标，可以采用SOA来改善原有架构，业务计算的问题解决后，数据库便成了整个系统中的瓶颈</p><h3 id="分库分表" tabindex="-1"><a class="header-anchor" href="#分库分表" aria-hidden="true">#</a> 分库分表</h3><p>数据库集群/分布式存储方案在当前最主流的便是采用分库分表方案做多机存储和负载</p><p>分库分表能减少单表</p><p>在多机存储的环境下，传统的事务机制便无法正常运行了。</p><h4 id="表垂直拆分" tabindex="-1"><a class="header-anchor" href="#表垂直拆分" aria-hidden="true">#</a> 表垂直拆分</h4><p>把表中的列拆分成多个部分，就是把一张很多字段的表，拆分成多个表</p><ul><li>减少查询时候的网络i/o</li><li>提高查询效率</li></ul><h4 id="表水平拆分" tabindex="-1"><a class="header-anchor" href="#表水平拆分" aria-hidden="true">#</a> 表水平拆分</h4><p>按行拆分，一张表里的行数越多，查询效率越低</p><p>水平拆分指定就是把原来的一张表中存放的数据按照固定行数拆分成多个表来存储</p><ul><li>有效的提高查询效率</li></ul><p>分表后依然可以使用本地事务，但是单机负载依然是瓶颈。</p><h4 id="分库" tabindex="-1"><a class="header-anchor" href="#分库" aria-hidden="true">#</a> 分库</h4><p>分库指的是</p><ul><li>同样的表结构</li><li>不同的数据库中</li><li>每个节点中保存副本数据或分布式存储</li><li>可以把事务路由到同一库中，则可以保证事务特性，尤其是强一致性</li><li>当数据分散到数据集群中做跨库查询的时候，无法保证强一致性</li></ul><h4 id="微服务下的多库存储" tabindex="-1"><a class="header-anchor" href="#微服务下的多库存储" aria-hidden="true">#</a> 微服务下的多库存储</h4><h4 id="回想cap定理和base理论" tabindex="-1"><a class="header-anchor" href="#回想cap定理和base理论" aria-hidden="true">#</a> 回想CAP定理和BASE理论</h4><p>base通过允许损失部分可用性来提高数据最终一致性</p><h2 id="海量数据-高并发系统分布式事务解决方案" tabindex="-1"><a class="header-anchor" href="#海量数据-高并发系统分布式事务解决方案" aria-hidden="true">#</a> 海量数据/高并发系统分布式事务解决方案</h2><h3 id="强一致性" tabindex="-1"><a class="header-anchor" href="#强一致性" aria-hidden="true">#</a> 强一致性</h3><p>强一致性会带来系统大量的损耗，存在单点故障问题，在提交事务阶段会产生阻塞，直到结束才会释放资源。高并发场景下表现并不好。</p><h2 id="刚性事物和柔性事物" tabindex="-1"><a class="header-anchor" href="#刚性事物和柔性事物" aria-hidden="true">#</a> 刚性事物和柔性事物</h2><ol><li>刚性事务：遵循ACID原则，强一致性。</li><li>柔性事务：遵循BASE理论，最终一致性</li></ol><h2 id="分布式事务解决方案" tabindex="-1"><a class="header-anchor" href="#分布式事务解决方案" aria-hidden="true">#</a> 分布式事务解决方案</h2><h3 id="xa两阶段提交方案" tabindex="-1"><a class="header-anchor" href="#xa两阶段提交方案" aria-hidden="true">#</a> XA两阶段提交方案</h3><p>数据库实现xa协议，保证事务，mysql oracle等。</p><h4 id="一阶段提交" tabindex="-1"><a class="header-anchor" href="#一阶段提交" aria-hidden="true">#</a> 一阶段提交</h4><p>由单数据源数据库实现，以mysql为例，</p><ul><li>记录redolog</li><li>数据库通过redolog完成事务</li></ul><p>单节点提交简单直观，没有和其他节点的通讯，性能好</p><h4 id="二阶段提交" tabindex="-1"><a class="header-anchor" href="#二阶段提交" aria-hidden="true">#</a> 二阶段提交</h4><p>主要由商业数据库实现，但并不常用，强一致性，性能低</p><ul><li>增加中间角色，事务管理器，来收集各数据库事务状态</li><li>阻塞</li><li>事务管理器 是由数据库提供的中间件</li></ul><h3 id="接口查询" tabindex="-1"><a class="header-anchor" href="#接口查询" aria-hidden="true">#</a> 接口查询</h3><h3 id="tcc" tabindex="-1"><a class="header-anchor" href="#tcc" aria-hidden="true">#</a> TCC</h3><p>在互联网项目，电商系统，app领域占据主力地位</p><p>接口需要自己实现或使用第三方开源框架</p><p>二阶段提交改进</p><p>对代码有侵入</p><ul><li>Try</li><li>confirm</li><li>cancel</li></ul><p>有侵入性、需要做幂等操作</p><h4 id="二阶段提交协议" tabindex="-1"><a class="header-anchor" href="#二阶段提交协议" aria-hidden="true">#</a> 二阶段提交协议</h4><p>二阶段提交协议可以保证数据强一致性</p><p>二阶段</p><ul><li>准备</li><li>提交</li></ul><p>角色:</p><ul><li>协调者 <ul><li>负责收集准备信息（预提交）</li><li>准备完成，发起正式提交</li></ul></li><li>参与者 <ul><li>数据库</li></ul></li></ul><p>二阶段提交把事务分为两个阶段，即准备阶段和提交阶段，准备阶段负责收集每个参与者提交数据的预提交信息，其实是收集每个数据节点是否能够成功执行命令，</p><p>如果其中某些节点无法执行，那么会反馈给协调者失败信息，然后协调者会发送回滚信息到每个数据节点以保证一致性</p><p>如果全部返回准备好的消息，那么协调者会正式向数据节点提交数据变更。</p><h5 id="问题" tabindex="-1"><a class="header-anchor" href="#问题" aria-hidden="true">#</a> 问题</h5><p><strong>同步执行</strong></p><p>每一次收集准备信息都需要等所有数据节点返回信息，造成同步等待。</p><p><strong>单点故障</strong></p><p>需要考虑数据节点和协调者的单点故障问题</p><p><strong>执行提交</strong></p><p>数据节点提交变更，无法保证是否真正提交了</p><p>二阶段提交存在很多潜在和小概率问题，那么在数据一致性要求高的场景下会造成数据不一致的现象发生，一旦发生数据不一致的情况后，后续人工干预的操作会浪费大量的时间，对银行、余额这类业务，还有可能造成资产流失。</p><h4 id="三阶段提交协议" tabindex="-1"><a class="header-anchor" href="#三阶段提交协议" aria-hidden="true">#</a> 三阶段提交协议</h4><p>三阶段提交是对二阶段提交的改良版本，增加了预备阶段，解决了同步阻塞问题。</p><h4 id="tcc模式" tabindex="-1"><a class="header-anchor" href="#tcc模式" aria-hidden="true">#</a> TCC模式</h4><p><strong>TCC</strong></p><p>Try</p><ul><li>尝试</li><li>完成所有业务检查</li><li>隔离预留资源</li></ul><p>Confirm</p><ul><li>真正的执行业务</li><li>使用try阶段预留的资源</li><li>幂等</li></ul><p>Cancel</p><ul><li>混滚</li></ul><p>主业务</p><ul><li>发起事务</li></ul><p>事务管理器</p><ul><li>执行tcc操作</li><li>创建事务ID来记录整个事务链路</li><li>实现嵌套事务业务逻辑</li></ul><p>执行流程</p><p>第一阶段</p><ul><li>主业务调用所有子业务的try操作</li><li>事务管理器记录操作日志</li></ul><p>第二阶段</p><ul><li>所有try操作成功时，事务管理器执行confirm操作</li><li>有失败时，执行回滚cancel操作</li></ul><p>t -&gt; cc <strong>关系绑定</strong></p><p>T是由主业务发起的，CC操作和T操作不在一台机器上</p><ul><li>通过配置文件</li><li>通过Spring注解</li></ul><p>try阶段进行了锁定资源操作，锁定不成功就认为是不可进行的，锁定成功就最终一定会成功。</p><h5 id="框架" tabindex="-1"><a class="header-anchor" href="#框架" aria-hidden="true">#</a> 框架</h5><p><strong>tcc-transaction</strong></p><p>https://github.com/changmingxie/tcc-transaction</p><p><strong>Hmily</strong></p><p>https://dromara.org/website/zh-cn/</p><p><strong>ByteTCC</strong></p><p>https://github.com/liuyangming/ByteTCC</p><p><strong>AOP</strong></p><p>TCC 通过AOP，面向切面编程来对confirm/cancel操作透明化</p><p><strong>幂等</strong></p><p>数据库中的唯一索引</p><p>分布式锁</p><p>状态机</p><h4 id="补偿模式" tabindex="-1"><a class="header-anchor" href="#补偿模式" aria-hidden="true">#</a> 补偿模式</h4><p>重试</p><p>固定次数，固定时间，消息队列，定时任务</p><p>下一次访问修复</p><p>定时校对/核对 quartz、xxl-job、elastic-job</p>',111),p=[h];function n(d,t){return i(),e("div",null,p)}const s=a(l,[["render",n],["__file","Tce_d.html.vue"]]);export{s as default};
