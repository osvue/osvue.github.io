import{_ as a,p as n,q as s,a1 as e}from"./framework-d81ad7e5.js";const t="/assets/ba-b0c8322c.png",o="/assets/bb-421bdfc9.png",p="/assets/bc-e1d169d5.png",r="/assets/bd-48bcc0d0.png",c="/assets/be-c07adc92.png",l="/assets/bf-afce710b.png",i="/assets/bg-985f51d6.png",d="/assets/bh-0767dfdd.png",u={},h=e(`<h2 id="堆内布局以及java对象在内存中的布局" tabindex="-1"><a class="header-anchor" href="#堆内布局以及java对象在内存中的布局" aria-hidden="true">#</a> 堆内布局以及Java对象在内存中的布局</h2><div class="language-java" data-ext="java"><pre class="language-java"><code>	<span class="token keyword">private</span> <span class="token class-name">Object</span> obj1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token class-name">Object</span> obj2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre></div><p>方法区存储每个类的结构，比如：运行时常量池、属性和方法数据，以及方法和构造函数等数据。所以我们这个obj1是存在方法区的，而new会创建一个对象实例，对象实例是存储在堆内的，于是就有了下面这幅图(<strong>方法区指向堆</strong>)：</p><p><img src="`+t+'" alt="alert"> 而obj2 是属于方法内的局部变量，存储在Java虚拟机栈内的栈帧中的局部变量表内，这就是经典的栈指向堆： <img src="'+o+'" alt="alert"></p><p>对象内存中可以分为三块区域：对象头(Header)，实例数据(Instance Data)和对齐填充(Padding)，以64位操作系统为例(未开启指针压缩的情况)Java对象布局如下图所示 <img src="'+p+'" alt="alert"></p><p>其中对象头中的Mark Word中的详细信息在文章synchronized锁升级原理中有详细介绍。上图中的<strong>对齐填充</strong>不是一定有的，如果对象头和实例数据加起来刚好是8字节的倍数，那么就不需要对齐填充。</p><h3 id="堆内存" tabindex="-1"><a class="header-anchor" href="#堆内存" aria-hidden="true">#</a> 堆内存</h3><p>上面 提到，在Java对象头当中的Mark Word存储了对象的分代年龄，那么什么是分代年龄呢？</p><p>一个对象的分代年龄可以理解为垃圾回收次数，当一个对象经过一次垃圾回收之后还存在，那么分代年龄就会加1，在64位的虚拟机中，分代年龄占了4位，最大值为15。分代年龄默认为0000，随着垃圾回收次数，会逐渐递增。</p><p>Java堆内存中按照分代年龄来划分，分为Young区和Old区，对象分配首先会到Young区，达到一定分代年龄(-XX:MaxTenuringThreshold可以设置大小，默认为15)就会进入Old区(注意：如果一个对象太大，那么就会直接进入Old区)。</p><p>之所以会这么划分是因为如果整个堆只有一个区的话，那么垃圾回收的时候每次都需要把堆内所有对象都扫描一遍，浪费性能。而其实大部分Java对象的生命周期都是很短的，一旦一个对象回收很多次都回收不掉，可以认为下一次垃圾回收的时候可能也回收不掉，所以Young区和Old区的垃圾回收可以分开进行，只有当Young区在进行垃圾回收之后还是没有腾出空间，那么再去触发Old区的垃圾回收。</p><p><img src="'+r+'" alt="alert"></p><h3 id="young区" tabindex="-1"><a class="header-anchor" href="#young区" aria-hidden="true">#</a> Young区</h3><p>现在拆分成了Young区，那我们看下面一个场景，下面的Young是经过垃圾回收之后的一个概图： <img src="'+c+'" alt="alert"> 假如说现在来了一个对象，要占用2个对象的大小，会发现放不下去了，这时候就会触发GC(垃圾回收)，但是一旦触发了GC(垃圾回收)，对用户线程是有影响的，因为GC过程中为了确保对象引用不会不断变化，需要停止所有用户线程，Sun把这个事件称之为：Stop the World(STW)。这些在下一篇讲解垃圾回收的时候会详细介绍，这里先不深入。</p><p>所以说一般是越少GC越好，而实际上上图中可以看到至少还可以放入3个对象，只要按照对象都按照顺序放好，那么是可以放得下的，所以这就产生了问题了，明明有空间，但是因为空间不连续，导致对象申请内存失败，导致触发GC了，那么如何解决这种问题呢？</p><p>解决的思路就是把Young区的对象按顺序放好，所以就产生了一个方法，把Young区再次划分一下，分为2个区：Eden区和Survivor区。 <img src="'+l+'" alt="alert"> 具体操作是：一个对象来了之后，先分配到Eden区，Eden区满了之后，触发GC，经过GC之后，为了防止空间不连续，把幸存下来的对象复制到Survivor区，然后Eden区就可以完整清理掉了，当然这么做是有一个前提的，就是大部分对象都是生命周期极短的，基本一次垃圾回收就可以把Eden区大部分对象回收掉（这个前提是经过测试总结得到的）。</p><p>触发GC的时候Survivor区也会一起回收，并不是说单独只触发Eden区，但是这样问题又来了，Eden区是保证空间基本连续了，但是Survivor区又可能产生空间碎片，导致不连续了，所以就又把Survivor区给一分为二了： <img src="'+i+'" alt="alert"> 这个时候工作流程又变成这样了：首先还是在Eden区分配空间，Eden区满了之后触发GC，GC之后把幸存对象 复制到S0区(S1区是空的)，然后继续在Eden区分配对象，再次触发GC之后如果发现S0区放不下了(产生空间碎片，实际还有空间)，那么就把S0区对象复制到S1区，并把幸存对象也复制到S1区，这时候S0区是空的了，并依次反复操作，假如说S0区或者S1区空间对象复制移动了之后还是放不下，那就说明这时候是真的满了，那就去老年区借点空间过来（这就是担保机制，老年代需要提供这种空间分配担保），假如说老年区空间也不够了，那就会触发Full GC，如果还是不够，那就会抛出OutOfMemeoyError异常了。</p><p>注意：为了确保S0和S1两个区域之间每次复制都能顺利进行，S0和S1两个区的大小必须要保持一致，而且同一时间有一个区域一定是空的。虽然说这种做法是会导致了一小部分空间的浪费，但是综合其他性能的提升来说，是值得的。</p><h3 id="old区" tabindex="-1"><a class="header-anchor" href="#old区" aria-hidden="true">#</a> Old区</h3><p>当Young区的对象达到设置的分代年龄之后，对象会进入Old区，Old区满了之后会触发Full GC，如果还是清理不掉空间，那么就抛出OutOfMemeoyError异常。</p><h3 id="名词扫盲" tabindex="-1"><a class="header-anchor" href="#名词扫盲" aria-hidden="true">#</a> 名词扫盲</h3><p>上面提到了很多新的名词，而实际上很多这种名词还有其他叫法，这个还是觉得有必要了解一下。</p><ul><li>垃圾回收：简称GC。</li><li>Minor GC：针对新生代的GC</li><li>Major GC：针对老年代的GC，一般老年代触发GC的同时也会触发Minor GC，也就等于触发了Full GC。</li><li>Full GC：新生代+老年代同时发生GC。</li><li>Young区：新生代</li><li>Old区：老年代</li><li>Eden区：暂时没发现有什么中文翻译(伊甸园?)</li><li>Surcivor区：幸存区</li><li>S0和S1：也称之为from区和to区，注意from和to两个区是不断互换身份的，且S0和S1一定要相等，并且保证一块区域是空的</li></ul><h3 id="一个对象的人生轨迹图" tabindex="-1"><a class="header-anchor" href="#一个对象的人生轨迹图" aria-hidden="true">#</a> 一个对象的人生轨迹图</h3><p>从上面的介绍大家应该有一个大致的印象，一个对象会在Eden区，S0区，S1区，Old区不断流转（当然，一开始就会被回收的短命对象除外），我们可以得到下面的一个流程图： <img src="'+d+'" alt="alert"></p>',25),g=[h];function k(m,_){return n(),s("div",null,g)}const S=a(u,[["render",k],["__file","jvm_men.html.vue"]]);export{S as default};
