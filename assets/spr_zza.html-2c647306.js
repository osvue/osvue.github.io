import{_ as e,p as a,q as r,a1 as i}from"./framework-d81ad7e5.js";const n={},t=i('<h3 id="工具类如何获取到-spring-容器中的-bean" tabindex="-1"><a class="header-anchor" href="#工具类如何获取到-spring-容器中的-bean" aria-hidden="true">#</a> 工具类如何获取到 Spring 容器中的 Bean</h3><h3 id="_1-aware-接口" tabindex="-1"><a class="header-anchor" href="#_1-aware-接口" aria-hidden="true">#</a> 1.Aware 接口</h3><ul><li>Spring 容器最大的特点在于所有的 Bean 对于 Spring 容器的存在是没有意识的，</li><li>因此我们常说理论上你可以无缝将 Spring 容器切换为其他容器（然而在现实世界中，我们其实没有这样的选择，除了 Spring 容器，难道还有更好用的？）。</li></ul><ul><li><p>当然这只是一个理论，在实际开发中，我们往往要用到 Spring 容器为我们提供的诸多资源，例如想要获取到容器中的配置、获取到容器中的 Bean 等等。在这种情况下，就需要 Spring 容器中的 Bean 真正的意识到 Spring 容器的存在，才能要到这些东西，那么如何让一个 Bean 意识到 Spring 容器的存在呢？</p></li><li><p>这就依赖于 Spring 容器给我们提供的各种 Aware 接口了。</p></li></ul><h3 id="aware-的作用如下" tabindex="-1"><a class="header-anchor" href="#aware-的作用如下" aria-hidden="true">#</a> Aware 的作用如下：</h3><ul><li>ApplicationEventPublisherAware：实现该接口的对象可以获取事件发布的能力。</li><li>ServletContextAware：实现该接口的对象可以获取到 ServletContext 对象。</li><li>MessageSourceAware：实现该接口的对象可以获取到 MessageSource 对象，MessageSource 支持多消息源，主要用于主要用于国际化。</li><li>ResourceLoaderAware：实现该接口的对象可以获取到一个 ResourceLoader，Spring ResourceLoader 则为我们提供了一个统一的 getResource() 方法来通过资源路径检索外部资源，例如文本文件、XML 文件、属性文件或图像文件等。</li><li>ApplicationStartupAware：实现该接口的对象可以获取到一个 ApplicationStartup 对象，这个比较新，是 Spring 5.3 中新推出的，通过 ApplicationStartup 可以标记应用程序启动期间的步骤，并收集有关执行上下文或其处理时间的数据。</li><li>NotificationPublisherAware：实现该接的对象可以获取到一个 NotificationPublisher 对象，通过该对象可以实现通知的发送。</li><li>EnvironmentAware：实现该接口的对象可以获取到一个 Environment 对象，通过 Environment 可以获取到容器的环境信息。</li><li>BeanFactoryAware：实现该接口的对象可以获取到一个 BeanFactory 对象，通过 BeanFactory 可以完成 Bean 的查询等操作。</li><li>ImportAware：实现该接口的对象可以获取到一个 AnnotationMetadata 对象，ImportAware 接口是需要和 @Import 注解一起使用的。在 @Import 作为元注解使用时，通过 @Import 导入的配置类如果实现了 ImportAware 接口就可以获取到导入该配置类接口的数据配置。</li><li>EmbeddedValueResolverAware：实现该接口的对象可以获取到一个 StringValueResolver 对象，通过 StringValueResolver 对象，可以读取到 Spring 容器中的 properties 配置的值（YAML 配置也可以）。</li><li>ServletConfigAware：实现该接口的对象可以获取到一个 ServletConfig 对象，不过这个似乎没什么用，我们很少自己去配置 ServletConfig。</li><li>LoadTimeWeaverAware：实现该接口的对象可以获取到一个 LoadTimeWeaver 对象，通过该对象可以获取加载 Spring Bean 时织入的第三方模块，如 AspectJ 等。</li><li>BeanClassLoaderAware：实现该接口的对象可以获取到一个 ClassLoader 对象，ClassLoader 能干嘛不需要我多说了吧。</li><li>BeanNameAware：实现该接口的对象可以获取到一个当前 Bean 的名称。</li><li>ApplicationContextAware：实现该接口的对象可以获取到一个 ApplicationContext 对象，通过 ApplicationContext 可以获取容器中的 Bean、环境等信息。</li></ul><ul><li><strong>这是 Spring 中提供的一堆 Aware</strong>。</li></ul><h2 id="beanfactorypostprocessor" tabindex="-1"><a class="header-anchor" href="#beanfactorypostprocessor" aria-hidden="true">#</a> BeanFactoryPostProcessor</h2>',8),l=[t];function o(s,p){return a(),r("div",null,l)}const d=e(n,[["render",o],["__file","spr_zza.html.vue"]]);export{d as default};
