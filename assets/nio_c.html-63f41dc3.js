import{_ as n,p as s,q as a,a1 as e}from"./framework-d81ad7e5.js";const p={},t=e(`<h2 id="缓冲区-buffer" tabindex="-1"><a class="header-anchor" href="#缓冲区-buffer" aria-hidden="true">#</a> 缓冲区（Buffer）</h2><blockquote><p>缓冲区本质上是一个可以读写数据的内存块，可以理解成是一个容器对象(含数组)，该对象提供了一组方法，可以更轻松地使用内存块，，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。Channel 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer，</p></blockquote><h3 id="常用buffer子类一览" tabindex="-1"><a class="header-anchor" href="#常用buffer子类一览" aria-hidden="true">#</a> 常用Buffer子类一览</h3><ul><li>ByteBuffer，存储字节数据到缓冲区</li><li>ShortBuffer，存储字符串数据到缓冲区</li><li>CharBuffer，存储字符数据到缓冲区</li><li>IntBuffer，存储整数数据到缓冲区</li><li>LongBuffer，存储长整型数据到缓冲区</li><li>DoubleBuffer，存储小数到缓冲区</li><li>FloatBuffer，存储小数到缓冲区</li></ul><div class="language-java" data-ext="java"><pre class="language-java"><code>
  <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Buffer</span> <span class="token punctuation">{</span>
    <span class="token comment">//JDK1.4时，引入的api</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">capacity</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token comment">//返回此缓冲区的容量</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">position</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token comment">//返回此缓冲区的位置</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">Buffer</span> position <span class="token punctuation">(</span><span class="token keyword">int</span>  newPositio<span class="token punctuation">)</span><span class="token comment">//设置此缓冲区的位置</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">limit</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token comment">//返回此缓冲区的限制</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">Buffer</span> limit <span class="token punctuation">(</span><span class="token keyword">int</span> newLimit<span class="token punctuation">)</span><span class="token comment">//设置此缓冲区的限制</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">Buffer</span> <span class="token function">mark</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token comment">//在此缓冲区的位置设置标记</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">Buffer</span> <span class="token function">reset</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token comment">//将此缓冲区的位置重置为以前标记的位置</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">Buffer</span> <span class="token function">clear</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token comment">//清除此缓冲区, 即将各个标记恢复到初始状态，但是数据并没有真正擦除, 后面操作会覆盖</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">Buffer</span> <span class="token function">flip</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token comment">//反转此缓冲区</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">Buffer</span> <span class="token function">rewind</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token comment">//重绕此缓冲区</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">remaining</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token comment">//返回当前位置与限制之间的元素数</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">hasRemaining</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token comment">//告知在当前位置和限制之间是否有元素</span>
    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">boolean</span> <span class="token function">isReadOnly</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//告知此缓冲区是否为只读缓冲区</span>
    <span class="token comment">//JDK1.6时引入的api</span>
    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">boolean</span> <span class="token function">hasArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//告知此缓冲区是否具有可访问的底层实现数组</span>
    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token class-name">Object</span> <span class="token function">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回此缓冲区的底层实现数组</span>
    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">int</span> <span class="token function">arrayOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//返回此缓冲区的底层实现数组中第一个缓冲区元素的偏移量</span>
    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">boolean</span> <span class="token function">isDirect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//告知此缓冲区是否为直接缓冲区</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="通道-channel" tabindex="-1"><a class="header-anchor" href="#通道-channel" aria-hidden="true">#</a> 通道(Channel)</h2><ol><li><p>通道可以同时进行读写，而流只能读或者只能写，通道可以实现异步读写数据， 通道可以从缓冲读数据，也可以写数据到缓冲:</p></li><li><p>BIO 中的 stream 是单向的，例如 FileInputStream 对象只能进行读取数据的操作，而 NIO 中的通道(Channel)是双向的，可以读操作，也可以写操作。</p></li><li><p>Channel在NIO中是一个接口\vpublic interface Channel extends Closeable{}</p></li><li><p>常用的 Channel 类有：FileChannel、DatagramChannel、ServerSocketChannel 和 SocketChannel。【ServerSocketChanne 类似 ServerSocket , SocketChannel 类似 Socket】</p></li><li><p>FileChannel 用于文件的数据读写，DatagramChannel 用于 UDP 的数据读写，ServerSocketChannel 和 SocketChannel 用于 TCP 的数据读写。</p></li></ol><h2 id="selector-选择器" tabindex="-1"><a class="header-anchor" href="#selector-选择器" aria-hidden="true">#</a> Selector(选择器)</h2><ol><li><p>Java 的 NIO，用非阻塞的 IO 方式。可以用一个线程，处理多个的客户端连接，就会使用到Selector(选择器)</p></li><li><p>Selector 能够检测多个注册的通道上是否有事件发生(注意:多个Channel以事件的方式可以注册到同一个Selector)，如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。【示意图】</p></li><li><p>只有在 连接/通道 真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程</p></li><li><p>避免了多线程之间的上下文切换导致的开销</p></li></ol>`,9),o=[t];function c(l,k){return s(),a("div",null,o)}const u=n(p,[["render",c],["__file","nio_c.html.vue"]]);export{u as default};
