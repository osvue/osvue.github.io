import{_ as o,M as p,p as c,q as i,R as n,t as a,N as t,a1 as e}from"./framework-d81ad7e5.js";const l="/assets/sprinit-ae022490.jpg",u="/assets/kzd-95ac7648.webp",r={},k=e('<ul><li><p>bean生命周期https://www.jianshu.com/p/9469cdd063e1</p></li><li><p>扩展知识之spring一些重要接口和类的使用 https://www.jianshu.com/p/79dd91b348c7</p></li><li><p>Spring的代理模式有两种：</p><ul><li>java自带的动态代理模式和cglib代理模式</li><li>cglib代码模式适用于没有接口的类</li><li>而java自带适用于接口类，默认情况下spring boot或者spring 采用接口类的代理模式，</li><li>如果我们是基于接口编程的，是不会发生问题的，但是如果我们定义了一个<strong>class类继承Base类</strong>的时候就会出问题了</li></ul></li></ul><blockquote><p>1、Spring容器在启动的时候，先会保存所有注册进来的Bean的定义信息</p></blockquote><blockquote><p>2、Spring容器会合适的时机创建这些Bean，比如用到这个bean的时候；利用getBean创建bean；创建好以后保存在容器中；</p></blockquote><blockquote><p>3、后置处理器BeanPostProcessor.每一个bean创建完成，都会使用各种后置处理器进行处理；来增强bean的功能,比如处理自动注入的后置处理器AutowiredAnnotationBeanPostProcessor</p></blockquote><blockquote><p>4、spring的事件驱动模型</p></blockquote><ul><li>ApplicationListener；事件监听</li><li>ApplicationEventMulticaster；事件派发</li></ul><hr><h2 id="spring-扩展点" tabindex="-1"><a class="header-anchor" href="#spring-扩展点" aria-hidden="true">#</a> spring 扩展点</h2><ul><li><p>Spring的核心思想就是容器，当容器refresh的时候，外部看上去风平浪静，其实内部则是一片惊涛骇浪，汪洋一片。</p></li><li><p>Springboot更是封装了Spring，遵循<strong>约定大于配置</strong>，加上<strong>自动装配</strong>的机制。很多时候我们只要引用了一个依赖，几乎是零配置就能完成一个功能的装配。</p><ul><li>了解spring对于bean的构造生命周期以及各个扩展接口。</li><li>了解bean的各个生命周期 加深对spring的理解。业务代码也能合理利用这些扩展点写出更加漂亮的代码。</li></ul></li></ul><h4 id="spring容器中bean的生命周期内所有可扩展的点的调用顺序" tabindex="-1"><a class="header-anchor" href="#spring容器中bean的生命周期内所有可扩展的点的调用顺序" aria-hidden="true">#</a> spring容器中Bean的生命周期内所有可扩展的点的调用顺序</h4><p><img src="'+l+`" alt="alt"></p><h3 id="applicationcontextinitializer" tabindex="-1"><a class="header-anchor" href="#applicationcontextinitializer" aria-hidden="true">#</a> ApplicationContextInitializer</h3><blockquote><p><code>org.springframework.context.ApplicationContextInitializer</code></p></blockquote><p>这是整个spring容器在刷新之前初始化<code>ConfigurableApplicationContext</code>的回调接口，简单来说，就是在容器刷新之前调用此类的<code>initialize</code>方法。这个点允许被用户自己扩展。用户可以在整个spring容器还没被初始化之前做一些事情。</p><p>可以想到的场景可能为，在最开始激活一些配置，或者利用这时候class还没被类加载器加载的时机，进行动态字节码注入等操作。 扩展方式为：</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestApplicationContextInitializer</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationContextInitializer</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableApplicationContext</span> applicationContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;[ApplicationContextInitializer]&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>因为这时候spring容器还没被初始化，所以想要自己的扩展的生效，有以下三种方式：</p><ul><li>在启动类中用<code>springApplication.addInitializers(new TestApplicationContextInitializer())</code>语句加入</li><li>配置文件配置<code>context.initializer.classes=com.example.demo.TestApplicationContextInitializer</code></li><li>Spring SPI扩展，在spring.factories中加入<code>org.springframework.context.ApplicationContextInitializer=com.example.demo.TestApplicationContextInitializer</code></li></ul><h3 id="_1-applicationcontextinitializer" tabindex="-1"><a class="header-anchor" href="#_1-applicationcontextinitializer" aria-hidden="true">#</a> 1，ApplicationContextInitializer</h3><p>接口 实现方法：</p><ul><li>initialize(ConfigurableApplicationContext applicationContext)</li></ul><p>调用时机：配置初始化完成</p><ul><li>用于在spring容器刷新之前初始化Spring ConfigurableApplicationContext的回调接口。（就是在容器刷新之前调用该类的 initialize 方法。并将 ConfigurableApplicationContext 类的实例传递给该方法）</li><li>通常用于需要对应用程序上下文进行编程初始化的web应用程序中。例如，根据上下文环境注册属性源或激活配置文件等。</li><li>可排序的（实现Ordered接口，或者添加@Order注解）</li></ul><p>因为是在ApplicationContext之前调用的，所以无法由它管理初始化，只能通过配置。有3种方法</p><h4 id="_1-1-配置文件" tabindex="-1"><a class="header-anchor" href="#_1-1-配置文件" aria-hidden="true">#</a> 1.1，配置文件</h4><div class="language-undefined" data-ext="undefined"><pre class="language-undefined"><code>context.initializer.classes=com.example.demo.test.TestSpringInitProcess
</code></pre></div><h4 id="_1-2-main方法里" tabindex="-1"><a class="header-anchor" href="#_1-2-main方法里" aria-hidden="true">#</a> 1.2，Main方法里</h4><div class="language-java" data-ext="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">SpringApplication</span> sa <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SpringApplication</span><span class="token punctuation">(</span><span class="token class-name">MainApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        sa<span class="token punctuation">.</span><span class="token function">addInitializers</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TestSpringInitProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        sa<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
</code></pre></div><h4 id="_1-3-springboot的spi扩展-meta-inf-spring-factories中配置" tabindex="-1"><a class="header-anchor" href="#_1-3-springboot的spi扩展-meta-inf-spring-factories中配置" aria-hidden="true">#</a> 1.3，SpringBoot的SPI扩展---META-INF/spring.factories中配置</h4><div class="language-undefined" data-ext="undefined"><pre class="language-undefined"><code>org.springframework.context.ApplicationContextInitializer=com.example.demo.test.TestSpringInitProcess
</code></pre></div><p>只会执行一次</p>`,31),d={href:"https://www.jianshu.com/writer#/notebooks/21700764/notes/84692259",target:"_blank",rel:"noopener noreferrer"},g=n("h3",{id:"_2-import",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_2-import","aria-hidden":"true"},"#"),a(" 2，@Import")],-1),m={href:"https://links.jianshu.com/go?to=https%3A%2F%2Fmy.oschina.net%2Fu%2F3058881%2Fblog%2F1673957",target:"_blank",rel:"noopener noreferrer"},b=e(`<div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@SpringBootApplication</span>
<span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token class-name">EnableConfigImport</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainApplication</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token class-name">MainApplication</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;MainApplication -&gt; constructor&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">SpringApplication</span> sa <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SpringApplication</span><span class="token punctuation">(</span><span class="token class-name">MainApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        sa<span class="token punctuation">.</span><span class="token function">addInitializers</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TestApplicationContextInitializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        sa<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EnableConfigImport</span> <span class="token keyword">implements</span> <span class="token class-name">ImportBeanDefinitionRegistrar</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">registerBeanDefinitions</span><span class="token punctuation">(</span><span class="token class-name">AnnotationMetadata</span> importingClassMetadata<span class="token punctuation">,</span> <span class="token class-name">BeanDefinitionRegistry</span> registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;EnableConfigImport -&gt; registerBeanDefinitions&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 这里可以做一些Bean的注册，这里注册的Bean，要早于其他 @Component 标注的类的注册</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestApplicationContextInitializer</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationContextInitializer</span><span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token class-name">TestApplicationContextInitializer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;TestApplicationContextInitializer -&gt; constructor&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableApplicationContext</span> applicationContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;TestApplicationContextInitializer -&gt; initialize&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><div class="language-css" data-ext="css"><pre class="language-css"><code>TestApplicationContextInitializer -&gt; constructor
TestApplicationContextInitializer -&gt; initialize
2021-03-05 15<span class="token punctuation">:</span>17<span class="token punctuation">:</span>03.309  INFO 14844 --- [           main] com.example.demo.<span class="token property">MainApplication</span>         <span class="token punctuation">:</span> Starting MainApplication on 
2021-03-05 15<span class="token punctuation">:</span>17<span class="token punctuation">:</span>03.314  INFO 14844 --- [           main] com.example.demo.<span class="token property">MainApplication</span>         <span class="token punctuation">:</span> No active profile set<span class="token punctuation">,</span> falling back to default <span class="token property">profiles</span><span class="token punctuation">:</span> default
EnableConfigImport -&gt; registerBeanDefinitions
</code></pre></div>`,2),y={href:"https://links.jianshu.com/go?to=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000021209356",target:"_blank",rel:"noopener noreferrer"},w={href:"https://www.jianshu.com/writer#/notebooks/21700764/notes/84692259",target:"_blank",rel:"noopener noreferrer"},f=e(`<h3 id="_3-beandefinitionregistrypostprocessor" tabindex="-1"><a class="header-anchor" href="#_3-beandefinitionregistrypostprocessor" aria-hidden="true">#</a> 3，BeanDefinitionRegistryPostProcessor</h3><p>接口 继承自 BeanFactoryPostProcessor 实现方法：</p><ul><li>postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException</li><li>postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException</li></ul><p>调用时机：这个接口在读取项目中的beanDefinition之后执行，提供一个补充的扩展点 使用场景：你可以在这里动态注册自己的beanDefinition，可以加载classpath之外的bean</p><p>实现这个接口的类必须是被Spring容器管理的类，也就是类上要有@Component等注解 两个函数会在构造函数执行完之后执行只会执行一次</p><h2 id="_4-beandefinitionregistrypostprocessor" tabindex="-1"><a class="header-anchor" href="#_4-beandefinitionregistrypostprocessor" aria-hidden="true">#</a> 4.BeanDefinitionRegistryPostProcessor</h2><blockquote><p>org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor</p></blockquote><p>这个接口在读取项目中的<code>beanDefinition</code>之后执行，提供一个补充的扩展点</p><p>使用场景：你可以在这里动态注册自己的<code>beanDefinition</code>，可以加载classpath之外的bean</p><p>扩展方式为:</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestBeanDefinitionRegistryPostProcessor</span> <span class="token keyword">implements</span> <span class="token class-name">BeanDefinitionRegistryPostProcessor</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postProcessBeanDefinitionRegistry</span><span class="token punctuation">(</span><span class="token class-name">BeanDefinitionRegistry</span> registry<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;[BeanDefinitionRegistryPostProcessor] postProcessBeanDefinitionRegistry&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postProcessBeanFactory</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableListableBeanFactory</span> beanFactory<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;[BeanDefinitionRegistryPostProcessor] postProcessBeanFactory&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_5-beanfactorypostprocessor" tabindex="-1"><a class="header-anchor" href="#_5-beanfactorypostprocessor" aria-hidden="true">#</a> 5.BeanFactoryPostProcessor</h2><blockquote><p>org.springframework.beans.factory.config.BeanFactoryPostProcessor</p></blockquote><p>这个接口是<code>beanFactory</code>的扩展接口，调用时机在spring在读取<code>beanDefinition</code>信息之后，实例化bean之前。</p><p>在这个时机，用户可以通过实现这个扩展接口来自行处理一些东西，比如修改已经注册的<code>beanDefinition</code>的元信息。</p><p>扩展方式为：</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestBeanFactoryPostProcessor</span> <span class="token keyword">implements</span> <span class="token class-name">BeanFactoryPostProcessor</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postProcessBeanFactory</span><span class="token punctuation">(</span><span class="token class-name">ConfigurableListableBeanFactory</span> beanFactory<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;[BeanFactoryPostProcessor]&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_6-instantiationawarebeanpostprocessor" tabindex="-1"><a class="header-anchor" href="#_6-instantiationawarebeanpostprocessor" aria-hidden="true">#</a> 6.InstantiationAwareBeanPostProcessor</h2><blockquote><p>org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor</p></blockquote><p>该接口继承了<code>BeanPostProcess</code>接口，区别如下：</p><p><strong><code>BeanPostProcess</code>接口只在bean的初始化阶段进行扩展（注入spring上下文前后），而<code>InstantiationAwareBeanPostProcessor</code>接口在此基础上增加了3个方法，把可扩展的范围增加了实例化阶段和属性注入阶段。</strong></p><p>该类主要的扩展点有以下5个方法，主要在bean生命周期的两大阶段：<strong>实例化阶段</strong>和<strong>初始化阶段</strong>，下面一起进行说明，按调用顺序为：</p><ul><li><code>postProcessBeforeInstantiation</code>：实例化bean之前，相当于new这个bean之前</li><li><code>postProcessAfterInstantiation</code>：实例化bean之后，相当于new这个bean之后</li><li><code>postProcessPropertyValues</code>：bean已经实例化完成，在属性注入时阶段触发，<code>@Autowired</code>,<code>@Resource</code>等注解原理基于此方法实现</li><li><code>postProcessBeforeInitialization</code>：初始化bean之前，相当于把bean注入spring上下文之前</li><li><code>postProcessAfterInitialization</code>：初始化bean之后，相当于把bean注入spring上下文之后</li></ul><p>使用场景：这个扩展点非常有用 ，无论是写中间件和业务中，都能利用这个特性。比如对实现了某一类接口的bean在各个生命期间进行收集，或者对某个类型的bean进行统一的设值等等。</p><p>扩展方式为：</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestInstantiationAwareBeanPostProcessor</span> <span class="token keyword">implements</span> <span class="token class-name">InstantiationAwareBeanPostProcessor</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">postProcessBeforeInitialization</span><span class="token punctuation">(</span><span class="token class-name">Object</span> bean<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;[TestInstantiationAwareBeanPostProcessor] before initialization &quot;</span> <span class="token operator">+</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">postProcessAfterInitialization</span><span class="token punctuation">(</span><span class="token class-name">Object</span> bean<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;[TestInstantiationAwareBeanPostProcessor] after initialization &quot;</span> <span class="token operator">+</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">postProcessBeforeInstantiation</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> beanClass<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;[TestInstantiationAwareBeanPostProcessor] before instantiation &quot;</span> <span class="token operator">+</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">postProcessAfterInstantiation</span><span class="token punctuation">(</span><span class="token class-name">Object</span> bean<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;[TestInstantiationAwareBeanPostProcessor] after instantiation &quot;</span> <span class="token operator">+</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">PropertyValues</span> <span class="token function">postProcessPropertyValues</span><span class="token punctuation">(</span><span class="token class-name">PropertyValues</span> pvs<span class="token punctuation">,</span> <span class="token class-name">PropertyDescriptor</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pds<span class="token punctuation">,</span> <span class="token class-name">Object</span> bean<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;[TestInstantiationAwareBeanPostProcessor] postProcessPropertyValues &quot;</span> <span class="token operator">+</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> pvs<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><h2 id="_7-smartinstantiationawarebeanpostprocessor" tabindex="-1"><a class="header-anchor" href="#_7-smartinstantiationawarebeanpostprocessor" aria-hidden="true">#</a> 7.SmartInstantiationAwareBeanPostProcessor</h2><blockquote><p>org.springframework.beans.factory.config.SmartInstantiationAwareBeanPostProcessor</p></blockquote><p>该扩展接口有3个触发点方法：</p><ul><li><code>predictBeanType</code>：该触发点发生在<code>postProcessBeforeInstantiation</code>之前(在图上并没有标明，因为一般不太需要扩展这个点)，这个方法用于预测Bean的类型，返回第一个预测成功的Class类型，如果不能预测返回null；当你调用<code>BeanFactory.getType(name)</code>时当通过bean的名字无法得到bean类型信息时就调用该回调方法来决定类型信息。</li><li><code>determineCandidateConstructors</code>：该触发点发生在<code>postProcessBeforeInstantiation</code>之后，用于确定该bean的构造函数之用，返回的是该bean的所有构造函数列表。用户可以扩展这个点，来自定义选择相应的构造器来实例化这个bean。</li><li><code>getEarlyBeanReference</code>：该触发点发生在<code>postProcessAfterInstantiation</code>之后，当有循环依赖的场景，当bean实例化好之后，为了防止有循环依赖，会提前暴露回调方法，用于bean实例化的后置处理。这个方法就是在提前暴露的回调方法中触发。</li></ul><p>扩展方式为：</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestSmartInstantiationAwareBeanPostProcessor</span> <span class="token keyword">implements</span> <span class="token class-name">SmartInstantiationAwareBeanPostProcessor</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">predictBeanType</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> beanClass<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;[TestSmartInstantiationAwareBeanPostProcessor] predictBeanType &quot;</span> <span class="token operator">+</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> beanClass<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Constructor</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">determineCandidateConstructors</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> beanClass<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;[TestSmartInstantiationAwareBeanPostProcessor] determineCandidateConstructors &quot;</span> <span class="token operator">+</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getEarlyBeanReference</span><span class="token punctuation">(</span><span class="token class-name">Object</span> bean<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;[TestSmartInstantiationAwareBeanPostProcessor] getEarlyBeanReference &quot;</span> <span class="token operator">+</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_8-beanfactoryaware" tabindex="-1"><a class="header-anchor" href="#_8-beanfactoryaware" aria-hidden="true">#</a> 8.BeanFactoryAware</h2><blockquote><p>org.springframework.beans.factory.BeanFactoryAware</p></blockquote><p>这个类只有一个触发点，发生在bean的实例化之后，注入属性之前，也就是Setter之前。这个类的扩展点方法为<code>setBeanFactory</code>，可以拿到<code>BeanFactory</code>这个属性。</p><p>使用场景为，你可以在bean实例化之后，但还未初始化之前，拿到 <code>BeanFactory</code>，在这个时候，可以对每个bean作特殊化的定制。也或者可以把<code>BeanFactory</code>拿到进行缓存，日后使用。</p><p>扩展方式为：</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestBeanFactoryAware</span> <span class="token keyword">implements</span> <span class="token class-name">BeanFactoryAware</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBeanFactory</span><span class="token punctuation">(</span><span class="token class-name">BeanFactory</span> beanFactory<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;[TestBeanFactoryAware] &quot;</span> <span class="token operator">+</span> beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">TestBeanFactoryAware</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_9-applicationcontextawareprocessor" tabindex="-1"><a class="header-anchor" href="#_9-applicationcontextawareprocessor" aria-hidden="true">#</a> 9.ApplicationContextAwareProcessor</h2><blockquote><p>org.springframework.context.support.ApplicationContextAwareProcessor</p></blockquote><p>该类本身并没有扩展点，但是该类内部却有6个扩展点可供实现 ，这些类触发的时机在bean实例化之后，初始化之前</p><p><img src="`+u+`" alt="img"></p><p>2.png</p><p>可以看到，该类用于执行各种驱动接口，在bean实例化之后，属性填充之后，通过执行以上红框标出的扩展接口，来获取对应容器的变量。<strong>所以这里应该来说是有6个扩展点</strong>，这里就放一起来说了</p><ul><li><code>EnvironmentAware</code>：用于获取<code>EnviromentAware</code>的一个扩展类，这个变量非常有用， 可以获得系统内的所有参数。当然个人认为这个Aware没必要去扩展，因为spring内部都可以通过注入的方式来直接获得。</li><li><code>EmbeddedValueResolverAware</code>：用于获取<code>StringValueResolver</code>的一个扩展类， <code>StringValueResolver</code>用于获取基于<code>String</code>类型的properties的变量，一般我们都用<code>@Value</code>的方式去获取，如果实现了这个Aware接口，把<code>StringValueResolver</code>缓存起来，通过这个类去获取<code>String</code>类型的变量，效果是一样的。</li><li><code>ResourceLoaderAware</code>：用于获取<code>ResourceLoader</code>的一个扩展类，<code>ResourceLoader</code>可以用于获取classpath内所有的资源对象，可以扩展此类来拿到<code>ResourceLoader</code>对象。</li><li><code>ApplicationEventPublisherAware</code>：用于获取<code>ApplicationEventPublisher</code>的一个扩展类，<code>ApplicationEventPublisher</code>可以用来发布事件，结合<code>ApplicationListener</code>来共同使用，下文在介绍<code>ApplicationListener</code>时会详细提到。这个对象也可以通过spring注入的方式来获得。</li><li><code>MessageSourceAware</code>：用于获取<code>MessageSource</code>的一个扩展类，<code>MessageSource</code>主要用来做国际化。</li><li><code>ApplicationContextAware</code>：用来获取<code>ApplicationContext</code>的一个扩展类，<code>ApplicationContext</code>应该是很多人非常熟悉的一个类了，就是spring上下文管理器，可以手动的获取任何在spring上下文注册的bean，我们经常扩展这个接口来缓存spring上下文，包装成静态方法。同时<code>ApplicationContext</code>也实现了<code>BeanFactory</code>，<code>MessageSource</code>，<code>ApplicationEventPublisher</code>等接口，也可以用来做相关接口的事情。</li></ul><h2 id="_10-beannameaware" tabindex="-1"><a class="header-anchor" href="#_10-beannameaware" aria-hidden="true">#</a> 10.BeanNameAware</h2><blockquote><p>org.springframework.beans.factory.BeanNameAware</p></blockquote><p>可以看到，这个类也是Aware扩展的一种，触发点在bean的初始化之前，也就是<code>postProcessBeforeInitialization</code>之前，这个类的触发点方法只有一个：<code>setBeanName</code></p><p>使用场景为：用户可以扩展这个点，在初始化bean之前拿到spring容器中注册的的beanName，来自行修改这个beanName的值。</p><p>扩展方式为：</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NormalBeanA</span> <span class="token keyword">implements</span> <span class="token class-name">BeanNameAware</span><span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">NormalBeanA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;NormalBean constructor&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBeanName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;[BeanNameAware] &quot;</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_11-postconstruct" tabindex="-1"><a class="header-anchor" href="#_11-postconstruct" aria-hidden="true">#</a> 11.@PostConstruct</h2><blockquote><p>javax.annotation.PostConstruct</p></blockquote><p>这个并不算一个扩展点，其实就是一个标注。其作用是在bean的初始化阶段，如果对一个方法标注了<code>@PostConstruct</code>，会先调用这个方法。这里重点是要关注下这个标准的触发点，这个触发点是在<code>postProcessBeforeInitialization</code>之后，<code>InitializingBean.afterPropertiesSet</code>之前。</p><p>使用场景：用户可以对某一方法进行标注，来进行初始化某一个属性</p><p>扩展方式为：</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NormalBeanA</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">NormalBeanA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;NormalBean constructor&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@PostConstruct</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;[PostConstruct] NormalBeanA&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_12-initializingbean" tabindex="-1"><a class="header-anchor" href="#_12-initializingbean" aria-hidden="true">#</a> 12.InitializingBean</h2><blockquote><p>org.springframework.beans.factory.InitializingBean</p></blockquote><p>这个类，顾名思义，也是用来初始化bean的。<code>InitializingBean</code>接口为bean提供了初始化方法的方式，它只包括<code>afterPropertiesSet</code>方法，凡是继承该接口的类，在初始化bean的时候都会执行该方法。这个扩展点的触发时机在<code>postProcessAfterInitialization</code>之前。</p><p>使用场景：用户实现此接口，来进行系统启动的时候一些业务指标的初始化工作。</p><p>扩展方式为：</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NormalBeanA</span> <span class="token keyword">implements</span> <span class="token class-name">InitializingBean</span><span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;[InitializingBean] NormalBeanA&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_13-factorybean" tabindex="-1"><a class="header-anchor" href="#_13-factorybean" aria-hidden="true">#</a> 13.FactoryBean</h2><blockquote><p>org.springframework.beans.factory.FactoryBean</p></blockquote><p>一般情况下，Spring通过反射机制利用bean的class属性指定支线类去实例化bean，在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式，则需要在bean中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。Spring为此提供了一个<code>org.springframework.bean.factory.FactoryBean</code>的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑。<code>FactoryBean</code>接口对于Spring框架来说占用重要的地位，Spring自身就提供了70多个<code>FactoryBean</code>的实现。它们隐藏了实例化一些复杂bean的细节，给上层应用带来了便利。从Spring3.0开始，<code>FactoryBean</code>开始支持泛型，即接口声明改为<code>FactoryBean</code>的形式</p><p>使用场景：用户可以扩展这个类，来为要实例化的bean作一个代理，比如为该对象的所有的方法作一个拦截，在调用前后输出一行log，模仿<code>ProxyFactoryBean</code>的功能。</p><p>扩展方式为：</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestFactoryBean</span> <span class="token keyword">implements</span> <span class="token class-name">FactoryBean</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">TestFactoryBean<span class="token punctuation">.</span>TestFactoryInnerBean</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">TestFactoryBean<span class="token punctuation">.</span>TestFactoryInnerBean</span> <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;[FactoryBean] getObject&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TestFactoryBean<span class="token punctuation">.</span>TestFactoryInnerBean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">getObjectType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">TestFactoryBean<span class="token punctuation">.</span>TestFactoryInnerBean</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">TestFactoryInnerBean</span><span class="token punctuation">{</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_14-smartinitializingsingleton" tabindex="-1"><a class="header-anchor" href="#_14-smartinitializingsingleton" aria-hidden="true">#</a> 14.SmartInitializingSingleton</h2><blockquote><p>org.springframework.beans.factory.SmartInitializingSingleton</p></blockquote><p>这个接口中只有一个方法<code>afterSingletonsInstantiated</code>，其作用是是 在spring容器管理的所有单例对象（非懒加载对象）初始化完成之后调用的回调接口。其触发时机为<code>postProcessAfterInitialization</code>之后。</p><p>使用场景：用户可以扩展此接口在对所有单例对象初始化完毕后，做一些后置的业务处理。</p><p>扩展方式为：</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestSmartInitializingSingleton</span> <span class="token keyword">implements</span> <span class="token class-name">SmartInitializingSingleton</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterSingletonsInstantiated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;[TestSmartInitializingSingleton]&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_15-commandlinerunner" tabindex="-1"><a class="header-anchor" href="#_15-commandlinerunner" aria-hidden="true">#</a> 15.CommandLineRunner</h2><blockquote><p>org.springframework.boot.CommandLineRunner</p></blockquote><p>这个接口也只有一个方法：<code>run(String... args)</code>，触发时机为整个项目启动完毕后，自动执行。如果有多个<code>CommandLineRunner</code>，可以利用<code>@Order</code>来进行排序。</p><p>使用场景：用户扩展此接口，进行启动项目之后一些业务的预处理。</p><p>扩展方式为：</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestCommandLineRunner</span> <span class="token keyword">implements</span> <span class="token class-name">CommandLineRunner</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;[TestCommandLineRunner]&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_16-disposablebean" tabindex="-1"><a class="header-anchor" href="#_16-disposablebean" aria-hidden="true">#</a> 16.DisposableBean</h2><blockquote><p>org.springframework.beans.factory.DisposableBean</p></blockquote><p>这个扩展点也只有一个方法：<code>destroy()</code>，其触发时机为当此对象销毁时，会自动执行这个方法。比如说运行<code>applicationContext.registerShutdownHook</code>时，就会触发这个方法。</p><p>扩展方式为：</p><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NormalBeanA</span> <span class="token keyword">implements</span> <span class="token class-name">DisposableBean</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;[DisposableBean] NormalBeanA&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_17-applicationlistener" tabindex="-1"><a class="header-anchor" href="#_17-applicationlistener" aria-hidden="true">#</a> 17.ApplicationListener</h2><blockquote><p>org.springframework.context.ApplicationListener</p></blockquote><p>准确的说，这个应该不算spring&amp;springboot当中的一个扩展点，<code>ApplicationListener</code>可以监听某个事件的<code>event</code>，触发时机可以穿插在业务方法执行过程中，用户可以自定义某个业务事件。但是spring内部也有一些内置事件，这种事件，可以穿插在启动调用中。我们也可以利用这个特性，来自己做一些内置事件的监听器来达到和前面一些触发点大致相同的事情。</p><p>接下来罗列下spring主要的内置事件：</p><ul><li><p>ContextRefreshedEvent</p><p>ApplicationContext 被初始化或刷新时，该事件被发布。这也可以在<code>ConfigurableApplicationContext</code>接口中使用 <code>refresh()</code>方法来发生。此处的初始化是指：所有的Bean被成功装载，后处理Bean被检测并激活，所有Singleton Bean 被预实例化，<code>ApplicationContext</code>容器已就绪可用。</p></li><li><p>ContextStartedEvent</p><p>当使用 <code>ConfigurableApplicationContext</code> （ApplicationContext子接口）接口中的 start() 方法启动 <code>ApplicationContext</code>时，该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。</p></li><li><p>ContextStoppedEvent</p><p>当使用 <code>ConfigurableApplicationContext</code>接口中的 <code>stop()</code>停止<code>ApplicationContext</code> 时，发布这个事件。你可以在接受到这个事件后做必要的清理的工作</p></li><li><p>ContextClosedEvent</p><p>当使用 <code>ConfigurableApplicationContext</code>接口中的 <code>close()</code>方法关闭 <code>ApplicationContext</code> 时，该事件被发布。一个已关闭的上下文到达生命周期末端；它不能被刷新或重启</p></li><li><p>RequestHandledEvent</p><p>这是一个 web-specific 事件，告诉所有 bean HTTP 请求已经被服务。只能应用于使用DispatcherServlet的Web应用。在使用Spring作为前端的MVC控制器时，当Spring处理用户请求结束后，系统会自动触发该事件</p></li></ul>`,91);function h(B,v){const s=p("ExternalLinkIcon");return c(),i("div",null,[k,n("p",null,[a("用例："),n("a",d,[a("spring boot Appollo加载时间点"),t(s)])]),g,n("p",null,[a("注解 会在ApplicationContextInitializer 后执行，无论写在哪里 @Import(xx.class) xx.class 要实现ImportBeanDefinitionRegistrar 接口 用法 参考"),n("a",m,[a("@Import,ImportSelector,ImportBeanDefinitionRegistrar的详解"),t(s)])]),b,n("p",null,[n("a",y,[a("ImportBeanDefinitionRegistrar"),t(s)])]),n("p",null,[a("用例："),n("a",w,[a("spring boot Appollo加载时间点"),t(s)])]),f])}const A=o(r,[["render",h],["__file","index.html.vue"]]);export{A as default};
