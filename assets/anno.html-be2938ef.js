import{_ as i,p as n,q as o,a1 as a}from"./framework-d81ad7e5.js";const l={},e=a(`<h3 id="enableautoconfiguration" tabindex="-1"><a class="header-anchor" href="#enableautoconfiguration" aria-hidden="true">#</a> @EnableAutoConfiguration</h3><pre><code>   Spring Boot自动配置（auto-configuration）：尝试根据你添加的jar依赖自动配置你的Spring应用。例如，如果你的classpath下存在HSQLDB，并且你没有手动配置任何数据库连接beans，那么我们将自动配置一个内存型（in-memory）数据库”。你可以将@EnableAutoConfiguration或者@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。如果发现应用了你不想要的特定自动配置类，你可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。
</code></pre><h3 id="componentscan" tabindex="-1"><a class="header-anchor" href="#componentscan" aria-hidden="true">#</a> @ComponentScan</h3><pre><code>   表示将该类自动发现（扫描）并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。如果没有配置的话，Spring Boot会扫描启动类所在包下以及子包下的使用了@Service,@Repository等注解的类。
</code></pre><h3 id="configuration" tabindex="-1"><a class="header-anchor" href="#configuration" aria-hidden="true">#</a> @Configuration</h3><pre><code>   相当于传统的xml配置文件，如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。
</code></pre><h3 id="import" tabindex="-1"><a class="header-anchor" href="#import" aria-hidden="true">#</a> @Import</h3><pre><code>   用来导入其他配置类。
</code></pre><h3 id="importresource" tabindex="-1"><a class="header-anchor" href="#importresource" aria-hidden="true">#</a> @ImportResource</h3><pre><code>   用来加载xml配置文件。
</code></pre><h3 id="qualifier" tabindex="-1"><a class="header-anchor" href="#qualifier" aria-hidden="true">#</a> @Qualifier</h3><ul><li>@Qualifier限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者</li></ul><ul><li>@Qualifier注解了，qualifier的意思是合格者，通过这个标示，表明了哪个实现类才是我们所需要的，我们修改调用代码，</li><li>添加@Qualifier注解，需要注意的是@Qualifier的参数名称必须为我们之前定义@Bean注解的名称之一</li></ul><h3 id="primary" tabindex="-1"><a class="header-anchor" href="#primary" aria-hidden="true">#</a> @Primary</h3><ul><li>主要的 当IOC容器里面有多个对象里，那么会有冲突，可以使用这个注解来标记它为主要的使用对象</li></ul><h2 id="conditional派生注解" tabindex="-1"><a class="header-anchor" href="#conditional派生注解" aria-hidden="true">#</a> @Conditional派生注解</h2><ul><li><strong>@ConditionalOnJava</strong><ul><li>系统的java版本是否符合要求</li></ul></li><li><strong>@ConditionalOnBean</strong><ul><li>容器中存在指定Bean；</li></ul></li><li><strong>@ConditionalOnMissingBean</strong><ul><li>容器中不存在指定Bean；</li></ul></li><li><strong>@ConditionalOnExpression</strong><ul><li>满足SpEL表达式指定</li></ul></li><li><strong>@ConditionalOnClass</strong><ul><li>系统中有指定的类</li></ul></li><li><strong>@ConditionalOnMissingClass</strong><ul><li>系统中没有指定的类</li></ul></li><li><strong>@ConditionalOnSingleCandidate</strong><ul><li>容器中只有一个指定的Bean，或者这个Bean是首选Bean</li></ul></li><li><strong>@ConditionalOnProperty</strong><ul><li>系统中指定的属性是否有指定的值</li></ul></li><li><strong>@ConditionalOnResource</strong><ul><li>类路径下是否存在指定资源文件</li></ul></li><li><strong>@ConditionalOnWebApplication</strong><ul><li>当前是web环境</li></ul></li><li><strong>@ConditionalOnNotWebApplication</strong><ul><li>当前不是web环境</li></ul></li><li><strong>@ConditionalOnJndi</strong><ul><li>JNDI存在指定项</li></ul></li></ul><p>所有的条件配置之间的关系是并且的关系</p>`,18),r=[e];function t(u,d){return n(),o("div",null,r)}const c=i(l,[["render",t],["__file","anno.html.vue"]]);export{c as default};
