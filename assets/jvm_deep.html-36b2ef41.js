import{_ as n,p as s,q as a,a1 as t}from"./framework-d81ad7e5.js";const o="/assets/gc_tool-ba46372f.png",p="/assets/gcgc-0750d1d5.png",e={},l=t(`<ul><li><p><strong>新生代</strong></p><ul><li>Eden</li><li>S0</li><li>S1</li></ul></li><li><p><strong>老年代</strong></p></li><li><p><strong>metaSpace</strong></p></li></ul><ul><li><p>一个Java程序运行起来是一个进程</p><ul><li>这个进程对应着一个JVM实例 <ul><li>一个JVM实例对应着一个运行时数据区。 <ul><li>一个运行时数据区对应着一个方法区和一个堆。 <ul><li>一个进程中会有<strong>多个线程</strong>，这些 <strong>线程</strong>会<strong>共享方法区和堆区</strong>。</li></ul></li></ul></li></ul></li></ul></li><li><p>核心概述</p><ul><li>一个JVM实例只对应一个堆内存，堆内存也是Java内存管理的核心区域。</li></ul><ol><li>Java堆区在JVM启动的时候就被创建，空间大小也就确定了。是JVM管理的最大的一块内存空间。</li><li>堆内存大小是可以调节的，使用 <code>-Xms 和-Xmx</code>命令进行调节，其语法和栈空间大小一致。</li><li>Java虚拟机规范规定，堆可以处于物理上不连续的内存空间中，但在逻辑上他应该是被视为连续的。</li><li>所有的<strong>线程共享Java堆</strong>，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer , TLAB）。</li><li>所有的对象实例几乎都在堆空间分配，也有一些特殊情况不在堆空间分配。（比如逃逸分析，栈上分配等）</li><li>数组和对象可能永远不会存储在栈上，因为<strong>栈帧中保存引用</strong>，这个引用指向对象或者数组在堆中的位置。</li><li>在方法结束后，堆中的对象<strong>不会马上被移除</strong>，仅仅<strong>在垃圾收集的时候才会被移除</strong>。</li><li>堆是<strong>垃圾回收（GC）的重点</strong>区域。</li></ol></li></ul><ul><li>堆的空间大小使用<code>-Xms 和-Xmx</code>进行设置，其中<code>-Xms</code>表示的是Java启动的时候堆空间的大小，<code>-Xmx</code>表示的是堆空间最大的大小。</li></ul><ul><li><strong>堆空间大小设置</strong> 默认情况下，初始内存大小为物理电脑<strong>内存大小/64</strong>;最大内存大小为物理电脑<strong>内存大小/4</strong>。</li></ul><p>我们可以通过一下代码查看堆空间的起始大小和最大空间大小，并计算出我们的物理内存：</p><div class="language-java" data-ext="java"><pre class="language-java"><code> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//堆起始内存</span>
        <span class="token keyword">long</span> initialMemory <span class="token operator">=</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">totalMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">/</span> <span class="token number">1024</span><span class="token punctuation">;</span>
        <span class="token comment">//堆最大内存</span>
        <span class="token keyword">long</span> maxMemory <span class="token operator">=</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">maxMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">/</span> <span class="token number">1024</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;-Xms:&quot;</span> <span class="token operator">+</span> initialMemory <span class="token operator">+</span> <span class="token string">&quot;M&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;-Xmx:&quot;</span> <span class="token operator">+</span> maxMemory <span class="token operator">+</span> <span class="token string">&quot;M&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;系统内存大小为：&quot;</span> <span class="token operator">+</span> initialMemory <span class="token operator">*</span> <span class="token number">64</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">+</span> <span class="token string">&quot;G&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;系统内存大小为：&quot;</span> <span class="token operator">+</span> maxMemory <span class="token operator">*</span> <span class="token number">4</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">+</span> <span class="token string">&quot;G&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

</code></pre></div><h2 id="堆空间划分" tabindex="-1"><a class="header-anchor" href="#堆空间划分" aria-hidden="true">#</a> 堆空间划分</h2><ul><li><p>Java7及之前的堆内存逻辑上分为三部分：<strong>新生区 + 养老区+永久代</strong></p></li><li><p>Young Generation Space 新生区 <code>Young/new</code> 又被划分为<strong>Eden区和Survivor区</strong></p></li><li><p>Tenure Generation Space 养老区 <code>Old/Tenure</code></p></li><li><p><strong>Permanent Space</strong> 永久区 <code>Perm</code></p></li><li><p><strong>Java8及之后的堆内存逻辑上分为三部分：新生区 + 养老区+元空间</strong></p></li><li><p>Young Generation Space 新生区 <code>Young/new</code> 又被划分为<strong>Eden区和Survivor区</strong></p></li><li><p>Tenure Generation Space 养老区 <code>Old/Tenure</code></p></li><li><p><strong>Meta Space</strong> 元空间 <code>Meta</code></p></li></ul><p><img src="`+o+'" alt="alt"></p><ul><li><strong>堆的内存结构</strong></li></ul><ul><li>**年轻代空间是两个幸存者区和Eden区，而幸存者区大小一样并且只会有一个有数据。**也就是说幸存者区在某一时刻必定会有一个是没有数据的，也就是说不占空间，所以在计算的时候只算了一个幸存者区的空间</li></ul><h3 id="年轻代和老年代" tabindex="-1"><a class="header-anchor" href="#年轻代和老年代" aria-hidden="true">#</a> 年轻代和老年代</h3><ul><li>存储在JVM中的Java对象可以被划分为两类：</li></ul><ul><li>一类是<strong>生命周期较短</strong>的瞬时对象，这类对象的创建和向往都非常迅速。</li><li>一类是<strong>生命周期非常长</strong>，在某些极端的情况下还能够与JVM生命周期保持一致。</li></ul><ul><li>Java堆区进一步细分的话，可以分为<strong>年轻代<code>（YoungGen）和老年代(OldGen)</code></strong></li></ul><ul><li>其中年轻代又可以划分为<strong>Eden</strong>空间，<strong>Survivor0</strong>空间和<strong>Survivor1</strong>空间（有时候也叫作<code>from区和to</code>区。）</li></ul><h3 id="对象的分配过程" tabindex="-1"><a class="header-anchor" href="#对象的分配过程" aria-hidden="true">#</a> 对象的分配过程</h3><ol><li>new的对象先放在伊甸园 eden区，此区有大小限制。</li><li>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器对伊甸园区进行垃圾回收（Minor GC），将伊甸园区中不再被其他对象所引用对象进行销毁，再加载新的对象放到伊甸园区。</li><li>然后将伊甸园区的剩余对象移动到<strong>幸存者0区</strong>，此时对象的存活年龄+1。</li><li>如果再次触发垃圾回收，会将<strong>伊甸园区和幸存者0区</strong>的不再被其他对象所引用对象进行销毁，此时伊甸园区和幸存者0区存活的对象都会转移到<strong>幸存者1区</strong>，此时幸存者0区没有对象。</li><li>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区，每次年龄都会+1。</li></ol><p><img src="'+p+`" alt="alt"></p><ol start="6"><li>那什么时候会去养老区呢？可以设置次数，默认15次，也就是年龄达到16 的时候就会转到养老区了。可以设置参数 <code>-XX:MaxTenuringThreshold</code>来进行设置。</li><li>如果<code>(s0/ s1 )</code>幸存者区中相同年龄的所有对象大小的总和 <strong>大于</strong> 幸存者区空间的一半，年龄大于或等于该年龄的对象可以<strong>直接进入老年代</strong>，无须等到MaxTenuringThreshold的要求年龄。</li><li>在养老区相对悠闲，当养老区内存不足时，再次触发<code>GC:Major GC</code>,进行养老区的内存清理。</li><li>若养老区进行了Major GC之后发现依然无法进行对象的保存，就会产生OOM异常。</li></ol><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OutOfMem</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Picture</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Picture</span> picture <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Picture</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>picture<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token keyword">class</span> <span class="token class-name">Picture</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> img<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">Picture</span><span class="token punctuation">(</span><span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>img <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-bash" data-ext="sh"><pre class="language-bash"><code>
<span class="token string">&quot;C:\\Program Files\\Java\\jdk1.8.0_251<span class="token entity" title="\\b">\\b</span>in\\java.exe&quot;</span> <span class="token parameter variable">-Xms500m</span> <span class="token parameter variable">-Xmx500m</span> <span class="token string">&quot;-javaagent:D:\\iiid\\IntelliJ IDEA 2020.2.4\\lib\\idea_rt.jar=3180:D:\\iiid\\IntelliJ IDEA 2020.2.4<span class="token entity" title="\\b">\\b</span>in&quot;</span> <span class="token parameter variable">-Dfile.encoding</span><span class="token operator">=</span>UTF-8 
 com.osvue.fblock.jvm.OutOfMem
Exception <span class="token keyword">in</span> thread <span class="token string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space
	at com.osvue.fblock.jvm.Picture.<span class="token operator">&lt;</span>init<span class="token operator">&gt;</span><span class="token punctuation">(</span>OutOfMem.java:33<span class="token punctuation">)</span>
	at com.osvue.fblock.jvm.OutOfMem.main<span class="token punctuation">(</span>OutOfMem.java:20<span class="token punctuation">)</span>
</code></pre></div><ul><li><p>一开始Eden区不断增长，等Eden空间满了之后发生一次YGC（此时Eden是空的）,将存活的对象放在了幸存者区，之后不断有新对象创建，放在Eden区，等Eden空间满了之后再次发生YGC，此时由于幸存者区空间不够，会把对象放到老年代，而s1,s2会交替复制存活的对象</p></li><li><p>老年代则会一直接收从新生代过来的对象，直到老年代再也放不进去对象，进行<code>FGC/Major GC</code>.还是没有足够的空间，报错:<code>java.lang.OutOfMemoryError: Java heap space</code></p></li><li><p>这也就解释了为什么<strong>Eden是逐渐增长，幸存区交替出现，老年区台阶式的增长</strong>。</p></li><li><p>\`新对象创建放在Eden，不断放就会一直增长，Eden满了触发YGC，Eden变空，<strong>存活对象进入幸存区</strong>，之后创建的对象又会放在Eden，慢慢Eden又满了，再次触发YGC，此时想要放到幸存区，发现空间不够，所以<strong>幸存区（S0/S1）放到老年区</strong>，然后新对象放在另一半的幸存者区，此时老年区就会有对象，所以有了第一级台阶，如此反复，直到堆区空间占满。而<strong>元空间（Metaspace）<strong>存放的是</strong>类和其他的一些信息</strong>，一直不会变，所以元空间（Metaspace）基本保持不变。</p></li><li><p><strong>总结</strong></p></li></ul><ul><li>针对幸存者s0,s1区的总结：复制之后有交换，谁空谁是to.</li></ul><ul><li><p>关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在<strong>永久区/元空间</strong>收集。</p></li><li><p>JVM在进行GC时，并非每次都对三个内存（新生代，老年代，方法区）区域一起回收，大部分时候回收的都是指新生代。</p></li></ul><p>针对HotSpot虚拟机，他里边的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC）,一种是整堆收集（Full GC）. 部分收集不是完整收集整个Java堆的垃圾收集。其中又分为：</p><ul><li>新生代收集 <strong><code>（Minor GC/Young GC）</code></strong>:只是新生代（Eden,s0,s1）的垃圾收集 <ul><li>当年轻代空间不足时，就会触发<strong>Minor GC</strong>，这里的年轻代满指的是Eden代满，幸存者区满不会引发GC。每次Minor GC会清理年轻代的内存。</li></ul></li><li>老年代收集<code>（Major GC/ Old GC）</code>只是老年代的垃圾收集。（很多时候Major GC和Full GC混淆使用，需要具体分辨是老年代还是整堆收集），CMS GC 会单独手机老年代的行为。</li><li>混合收集<code>（Mixed GC）</code>手机真个新生代以及部分老年代的垃圾收集，G1会有这种行为。</li><li>整堆收集<code>（Full GC）</code>：收集整个Java堆和方法区的垃圾收集。</li></ul><h3 id="逃逸分析和栈上分配" tabindex="-1"><a class="header-anchor" href="#逃逸分析和栈上分配" aria-hidden="true">#</a> <strong>逃逸分析和栈上分配</strong></h3><ul><li>在JVM中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是有一种特殊情况，那就是如果经过<strong>逃逸分析后发现</strong>，一个对象并<strong>没有逃逸出方法</strong>的话，那么就可能 <strong>优化成栈上分配</strong>。这样就无需在堆内存 上分配内存，也无需进行垃圾回收了。这也是最常见的<strong>堆外存储技术</strong>。</li></ul><ul><li><strong>发生逃逸的情况：给成员变量赋值，方法返回值，实例引用传递</strong>。</li><li>避免发生逃逸</li></ul><ul><li>就看new的对象实体是否有可能在方法外被调用。</li><li>方法中<strong>能使用局部变量</strong>的，就不要使用在方法外定义。</li></ul><blockquote><p>由淘宝定制的TaoBaoVM 其中创建的GCIH（GC Invisible Heap）技术实现off-heap,将生命周期较长的Java对象从heap中移至heap外 并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p></blockquote><ul><li><p>通过逃逸分析，Java HotSpot编译器能够分析出一个新的对象的引用的适用范围从而决定是否哦要将这对象分配到堆上。</p><ul><li><strong>逃逸分析的基本行为就是分析对象动态作用域：</strong><ul><li>当一个对象在方法中被定义后，<strong>对象只在方法内部使用</strong>，则认为<strong>没有发生逃逸</strong>。</li><li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li></ul></li></ul></li></ul><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    user <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>上边<strong>没有发生逃逸</strong>的对象，则可以<strong>分配到栈</strong>上，随着方法执行的结束，栈空间就被移除。</li></ul><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">StringBuffer</span> <span class="token function">say</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token class-name">StringBuffer</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> sb<span class="token punctuation">;</span>   <span class="token doc-comment comment">/**  会发生逃逸  */</span>
    <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 因为StringBuffer是重写了toString，重新new了一个对象，所以返回的对象并不是sb本身。</span>

<span class="token punctuation">}</span>
</code></pre></div>`,36),c=[l];function u(i,r){return s(),a("div",null,c)}const g=n(e,[["render",u],["__file","jvm_deep.html.vue"]]);export{g as default};
