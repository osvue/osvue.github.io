import{_ as l,p as a,q as i,a1 as e}from"./framework-d81ad7e5.js";const t="/assets/fun-477242ff.png",r={},o=e('<h3 id="方法区的理解" tabindex="-1"><a class="header-anchor" href="#方法区的理解" aria-hidden="true">#</a> 方法区的理解</h3><ul><li>Java虚拟机规范中明确说明：尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。</li><li>但对于HotSpot虚拟机来说，方法区还有一个别名叫做非堆，目的就是要和堆分开。</li><li>所以，方法区看做是一块<strong>独立于Java堆</strong>的内存空间。</li><li>方法区与Java堆一样，是各个线程共享的内存区域。</li><li>方法区在JVM启动的时候被创建，并且它的实际物理内存空间和Java堆区一样都可以是不连续的。</li><li>方法区的大小跟堆空间一样，可以选择固定大小或者可扩展。</li><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：<code>java.lang.OutOfMemoryError:PermGen space(jdk7)</code> 或者<code>java.lang.OutOfMemoryError:Metaspace(jdk8)</code>. <ul><li>加载大量第三方jar包</li><li>tomcat部署的工程过多</li><li>大量动态的生成反射类</li></ul></li></ul><p><img src="'+t+'" alt="alt"></p><ul><li><p>关闭JVM就会释放这个区域的内存。</p></li><li><p>在jdk7及以前， 习惯上方法区称为永久代，jdk8开始，使用元空间取代了永久代。</p></li><li><p>本质上，方法区和永久代并不等价，仅是对Hotspot而言的。</p></li><li><p>使用永久代，会导致Java程序更容易OOM(超过-XX:MaxPermSize上限)。</p></li><li><p>到了jdk8,终于完全废弃了永久代的概念，改用JRockit,J9一样在**本地内存中实现的元空间（Metaspace）**来代替。</p></li></ul><h3 id="元空间" tabindex="-1"><a class="header-anchor" href="#元空间" aria-hidden="true">#</a> 元空间</h3><ul><li>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于： <ul><li><strong>元空间不在虚拟机设置的内存中，而是使用本地内存</strong>。</li></ul></li></ul>',6),s=[o];function c(n,d){return a(),i("div",null,s)}const u=l(r,[["render",c],["__file","jvm_fun.html.vue"]]);export{u as default};
