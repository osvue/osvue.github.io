import{_ as a,p as n,q as s,a1 as e}from"./framework-d81ad7e5.js";const l={},i=e(`<h2 id="mysql最要的特点" tabindex="-1"><a class="header-anchor" href="#mysql最要的特点" aria-hidden="true">#</a> MYSQL最要的特点</h2><ol><li>MYSQL的物理结构是索引组织表(Index Organized Table， IOT)，不是堆表(Heap Table)。</li><li>数据就是索引，索引就是数据。记录之间是有顺序关系的。这种结构导致很多在oracle上得到的经验都失效了。在使用MYSQL之前一定要清楚这一点。</li></ol><h2 id="数据库设计" tabindex="-1"><a class="header-anchor" href="#数据库设计" aria-hidden="true">#</a> 数据库设计</h2><h3 id="主键" tabindex="-1"><a class="header-anchor" href="#主键" aria-hidden="true">#</a> 主键</h3><ul><li>因为mysql的表是IOT，所以每张表一定要有主键，必须要有主键。</li><li>如果没有主键，mysql会自动创建一个主键和主键索引。</li><li>mysql所有的数据，也就是每条记录数据都是存放在主键索引中的。</li><li>这个和oracle中表数据和索引分开存储的方式是非常不同的。</li><li>在mysql中主键索引又叫聚簇索引(Clustered Index)。</li><li>表的主键是查询语句执行效率的关键点。</li></ul><h3 id="字符型数据" tabindex="-1"><a class="header-anchor" href="#字符型数据" aria-hidden="true">#</a> 字符型数据</h3><ul><li>mysql的字符型数据除了有字符集的区别外，还有有一个特殊地方就是需要指定字符集的比较策略(Collation)。 <ul><li>在不同比较策略下: <code> select &#39;A&#39; = &#39;a&#39; from dual;</code></li><li>这个语句会有不同的返回结果。 <ul><li>当数据库字符类型使用utf8mb4时，默认的Collation是utf8mb4_general_ci，忽略大小写。Collation 会影响语句的逻辑，索引的排序规则，检索效率。</li><li>强烈建议数据库字符类型使用utf8mb4，collation 使用utf8mb4_bin</li></ul></li></ul></li></ul><div class="language-conf" data-ext="conf"><pre class="language-conf"><code>#在配置文件中使用下面的参数；
default-character-set=utf8mb4
character-set-server=utf8mb4
collation_server=utf8mb4_bin

</code></pre></div><h3 id="辅助索引-或者次级索引-secondary-indexes" tabindex="-1"><a class="header-anchor" href="#辅助索引-或者次级索引-secondary-indexes" aria-hidden="true">#</a> 辅助索引，或者次级索引(Secondary Indexes)</h3><ul><li>mysql的辅助索引和主键索引是非常不同的。 <ul><li>主键索引存储完整的数据，辅助索引不存储数据，只存储指向数据主键的引用。</li><li>当使用辅助索引查找数据时，总是先找到主键的引用，然后再从主索引上找到数据。这个操作叫回表。这种查询是比较慢的，尤其是数据量大，查询频繁的时候。</li></ul></li></ul><h3 id="水平分表" tabindex="-1"><a class="header-anchor" href="#水平分表" aria-hidden="true">#</a> 水平分表</h3><ul><li>水平分表：常见的就是月度数据。如果数据量很大话，尽量按月度分开建表存储。在oracle中可以使用分区表来实现。mysql虽然也提供了分区表技术，但是有很多限制，比如： 主键必须包含分区键，或者分区表上没有主键。</li><li>建议人为水平分表，更可控。当然，缺点就是应用的代码也需要修改。</li></ul><h3 id="垂直分表" tabindex="-1"><a class="header-anchor" href="#垂直分表" aria-hidden="true">#</a> 垂直分表</h3><ul><li>垂直分表：常见的就是人员信息。把人员毕业证的照片，简历这些数据量比较大，平常又不查的数据存放到另外的表中。需要的时候，使用关联查询。</li></ul><h2 id="sql优化" tabindex="-1"><a class="header-anchor" href="#sql优化" aria-hidden="true">#</a> SQL优化</h2><h3 id="定位慢查询" tabindex="-1"><a class="header-anchor" href="#定位慢查询" aria-hidden="true">#</a> 定位慢查询</h3><div class="language-conf" data-ext="conf"><pre class="language-conf"><code># 启用慢查询日志，在配置文件中加入：
slow_query_log = 1
long_query_time = 2  #单位是秒，可以使用小数，0.2表示200毫秒。
slow_query_log_file = slow.log
log_queries_not_using_indexes = 1

</code></pre></div><h3 id="explain分析问题" tabindex="-1"><a class="header-anchor" href="#explain分析问题" aria-hidden="true">#</a> Explain分析问题</h3><ul><li>主要关注：是否使用了索引、使用的索引是否合适</li></ul><div class="language-sql" data-ext="sql"><pre class="language-sql"><code>
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">from</span> employees <span class="token keyword">where</span> emp_no <span class="token operator">&lt;</span> <span class="token number">20000</span><span class="token punctuation">;</span> 


</code></pre></div><ol><li>id //select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序</li><li>select_type //查询类型</li><li>table //正在访问哪个表</li><li>partitions //匹配的分区</li><li>type //访问的类型</li><li>possible_keys //显示可能应用在这张表中的索引，一个或多个，但不一定实际使用到</li><li>key //实际使用到的索引，如果为NULL，则没有使用索引</li><li>key_len //表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度</li><li>ref //显示索引的哪一列被使用了，如果可能的话，是一个常数，哪些列或常量被用于查找索引列上的值</li><li>rows //根据表统计信息及索引选用情况，大致估算出找到所需的记录所需读取的行数</li><li>filtered //查询的表行占表的百分比</li><li>Extra //包含不适合在其它列中显示但十分重要的额外信息</li></ol><h3 id="基本思路" tabindex="-1"><a class="header-anchor" href="#基本思路" aria-hidden="true">#</a> 基本思路</h3><ul><li>各种数据库的性能问题基本上都是两大类： <ol><li>减少 IO</li><li>减少CPU计算</li></ol></li></ul><ul><li>为了解决这两个问题，从开发人员的方法上只有一种： <ul><li>改变SQL的执行计划</li></ul></li></ul><h3 id="常见方式" tabindex="-1"><a class="header-anchor" href="#常见方式" aria-hidden="true">#</a> 常见方式</h3><p>对于mysql有一些针对性的方法，如下：</p><ol><li>尽量早过滤</li><li>少用子查询</li><li>尽量用join取代子查询</li><li>尽量少用or</li><li>尽量避免select *</li><li>用 union all 代替 union</li><li>在有索引的列上order by， group by</li><li>尽量避免在where中使用!=或&lt;&gt;操作符</li><li>尽量避免在where中对字段进行null值判断</li><li>尽量避免长事务</li><li>不要在索引列上计算</li></ol><h3 id="例-必要时强制查询优化器使用某个索引" tabindex="-1"><a class="header-anchor" href="#例-必要时强制查询优化器使用某个索引" aria-hidden="true">#</a> 例: 必要时强制查询优化器使用某个索引</h3><div class="language-sql" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span>    <span class="token operator">*</span> <span class="token keyword">from</span>  t1 <span class="token keyword">where</span>  nextprocess <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">and</span> processid <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token number">8</span> <span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">45</span><span class="token punctuation">)</span>


<span class="token keyword">select</span> <span class="token operator">*</span>  <span class="token keyword">from</span> t1 <span class="token keyword">use</span> <span class="token keyword">index</span> <span class="token punctuation">(</span>ix_processid<span class="token punctuation">)</span> <span class="token keyword">where</span>  nextprocess <span class="token operator">=</span> <span class="token number">1</span>   <span class="token operator">and</span> processid <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token number">8</span> <span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">45</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">-- 基本思路</span>
<span class="token comment">--拒绝3B:</span>
<span class="token comment">-- 大SQL (BIG SQL)</span>
<span class="token comment">-- 大事务 (BIG Transaction)</span>
<span class="token comment">-- 大批量 (BIG Batch)</span>

</code></pre></div>`,29),o=[i];function t(r,c){return n(),s("div",null,o)}const d=a(l,[["render",t],["__file","mysql_fk.html.vue"]]);export{d as default};
