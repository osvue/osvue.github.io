import{_ as a,p as l,q as i,a1 as e}from"./framework-d81ad7e5.js";const s="/assets/stack_inner-b3ff7088.png",r={},n=e(`<h3 id="反编译" tabindex="-1"><a class="header-anchor" href="#反编译" aria-hidden="true">#</a> 反编译</h3><div class="language-bash" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 终端进行反编译，执行 </span>
javap <span class="token parameter variable">-v</span> .<span class="token punctuation">\\</span>Test.class
</code></pre></div><h3 id="堆、栈" tabindex="-1"><a class="header-anchor" href="#堆、栈" aria-hidden="true">#</a> 堆、栈</h3><ul><li>在JVM中，栈是运行的单位，堆是存储的单位。</li></ul><ul><li><strong>栈解决程序运行问题，即程序如何执行</strong>，或者说如何处理数据，<strong>堆</strong>解决的是<strong>数据存储的问题，即数据怎么放，放在哪</strong>。</li><li>每个线程在创建时都会<strong>创建一个虚拟机栈</strong>，其内部保存一个个的栈帧（Stack Frame）,对应着<strong>一次次的java方法</strong>调用。是线程私有的，生命周期和线程一致。</li></ul><ul><li>虚拟机栈主管Java程序的运行，它保存方法的局部变量（8种数据类型，对象的引用地址），部分结果，并参与方法的调用和返回。</li></ul><ul><li>栈是<strong>先进后出</strong>，就像手枪弹夹，先放进去的子弹后被打出，最后放进去的子弹，先被打出。</li><li>栈遵循先进后出，后进先出的原则</li></ul><h3 id="栈空间大小设置" tabindex="-1"><a class="header-anchor" href="#栈空间大小设置" aria-hidden="true">#</a> 栈空间大小设置</h3><ul><li><p>可以使用参数-Xss来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</p></li><li><p>以KB为单位设置大小，就要在数字后边加上K或k,如： <code>-Xss1024K</code></p></li><li><p>以MB为单位设置大小，就要在数字后边加上M或m,如： <code>-Xss1024m</code></p></li><li><p>以GB为单位设置大小，就要在数字后边加上G或g,如： <code>-Xss1G</code></p></li></ul><h3 id="栈的内部结构" tabindex="-1"><a class="header-anchor" href="#栈的内部结构" aria-hidden="true">#</a> 栈的内部结构</h3><p><img src="`+s+'" alt="alt"></p><ul><li><p>每个栈帧中存储着：</p></li><li><p>局部变量表（Local variables）</p><ul><li>定义为一个数据数组，主要是用于存储方法参数和定义在方法体内的局部变量</li><li>这些数据类型包括各类<strong>基本数据类型</strong>，<strong>对象引用</strong>，以及returnAddress类型</li><li>局部变量表中存放编译期克制的各种基本数据类型（8种</li><li>局部变量表，最基本的存储单元是slot(变量槽)</li><li><strong>局部变量表中变量也是中要的垃圾回收根节点，主要被局部变量表中直接或间接引用的对象都不会被回收</strong>。</li></ul></li><li><p>操作数栈（Operand Stack）(或表达式栈)</p></li><li><p>动态链接（Dynamic Linking）(或指向运行时常量池的方法引用)</p><ul><li>每一个栈帧内部都包含一个指向 运行时常量池中该栈帧所属方法的引用。</li></ul></li><li><p>方法返回地址（Return Address）(或方法正常退出或者异常退出的定义)</p></li></ul><h3 id="虚方法和非虚方法" tabindex="-1"><a class="header-anchor" href="#虚方法和非虚方法" aria-hidden="true">#</a> 虚方法和非虚方法</h3><ul><li><p><strong>非虚方法</strong></p></li><li><p>如果方法在编译期就确定了具体的调用版本，这个版本在<strong>运行时是不可变</strong>的，这样的方法称为非虚方法。</p></li><li><p>静态方法，私有方法，final方法，实例构造器，父类方法都是非虚方法。</p></li><li><p>其他方法称为虚方法。</p></li></ul><ul><li><strong>方法的调用</strong> 在JVM中，将符号引用转换为调用方法的直接饮用与方法的绑定机制有关。</li></ul><h3 id="静态链接" tabindex="-1"><a class="header-anchor" href="#静态链接" aria-hidden="true">#</a> 静态链接</h3><ul><li>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期克制，切运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程城之后静态链接。</li></ul><h3 id="动态链接" tabindex="-1"><a class="header-anchor" href="#动态链接" aria-hidden="true">#</a> 动态链接</h3><ul><li>如果被调用的方法在编译期无法被确定下来， 也就是说只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种医用在转换过程具备动态性，因此也就城之后动态链接。 对应的方法绑定机制为早起绑定和晚期绑定。绑定是一个字段，方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</li></ul><h3 id="早期绑定" tabindex="-1"><a class="header-anchor" href="#早期绑定" aria-hidden="true">#</a> 早期绑定：</h3><ul><li>早期绑定就是指被调用的目标方法如果在编译期可知，却运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方法将符号引用转换为直接引用。</li></ul><h3 id="晚期绑定" tabindex="-1"><a class="header-anchor" href="#晚期绑定" aria-hidden="true">#</a> 晚期绑定：</h3><ul><li>如果被调用的方法在编译期无法被确定下来，只能在程序运行期根据实际的类型绑定相关的方法，这种绑定放在也就被称之为晚期绑定。 就比如方法参数传了一个父类或者接口，必须在真正运行的时候才能确定是哪一个子类进行操作，这就属于晚期绑定。</li></ul><h2 id="本地方法栈" tabindex="-1"><a class="header-anchor" href="#本地方法栈" aria-hidden="true">#</a> 本地方法栈</h2><ul><li><strong>Java虚拟机栈适用于管理Java方法的调用，而本地方法栈是用于管理本地方法的调用。</strong></li></ul><ul><li>本地方法 <ul><li>**本地方法（Native Method）就是一个Java调用非Java代码的接口。**本地方法的实现是由飞Java语言实现，比如c，这个特征并非Java所特有。很多其他变成语言都有这一机制。</li></ul></li></ul><ul><li>在定义一个Native Method时，并不提供实现体（像是定义一个Java interface的方法），因为实现体是由非Java语言在外边实现的。</li><li>在Object中的getClass就是一个本地方法。</li></ul>',27),t=[n];function d(h,o){return l(),i("div",null,t)}const u=a(r,[["render",d],["__file","jvm_stack.html.vue"]]);export{u as default};
