import{_ as e,p as l,q as s,a1 as i}from"./framework-d81ad7e5.js";const t={},o=i('<ol><li>在 MyBatis 运行开始时需要先通过 Resources 加载全局配置文件.</li><li>下面需要实例化 SqlSessionFactoryBuilder 构建器.帮助 SqlSessionFactory 接 口实现类 DefaultSqlSessionFactory.</li><li>在实例化 DefaultSqlSessionFactory 之前需要先创建 XmlConfigBuilder 解析全局配置文件流, 并把解析结果存放在 Configuration 中.</li><li>之后把 Configuratin 传递给 DefaultSqlSessionFactory.到此 SqlSessionFactory 工 厂创建成功.</li><li>由 SqlSessionFactory 工厂创建 SqlSession. 每次创建 SqlSession 时,都需要由 TransactionFactory 创建 Transaction 对象,</li><li>同时还需要创建 SqlSession 的执行器 Excutor,最后实例化 DefaultSqlSession,传递给 SqlSession 接口.</li><li>根据项目需求使用 SqlSession 接口中的 API 完成具体的事务操作.</li><li>如果事务执行失败,需要进行 rollback 回滚事务.</li><li>如果事务执行成功提交给数据库.关闭 SqlSession</li></ol><h2 id="缓存" tabindex="-1"><a class="header-anchor" href="#缓存" aria-hidden="true">#</a> 缓存</h2><div class="custom-container tip"><p class="custom-container-title">TIP</p><ol><li><p>应用程序和数据库交互的过程是一个相对比较耗时的过程</p></li><li><p>缓存存在的意义:让应用程序减少对数据库的访问,提升程序运行效率</p></li><li><p>MyBatis 中默认 SqlSession 缓存开启 3.1 同一个 SqlSession 对象调用同一个 select 时,只有第一次访问 数据库,第一次之后把查询结果缓存到 SqlSession 缓存区(内存)中 3.2 缓存的是 statement 对象.(简单记忆必须是用一个 select ) 3.2.1 在 myabtis 时一个 select 对应一个 statement 对象 3.3 有效范围必须是同一个 SqlSession 对象</p></li><li><p>缓存流程 4.1 步骤一: 先去缓存区中找是否存在 statement 4.2 步骤二:返回结果 4.3 步骤三:如果没有缓存 statement 对象,去数据库获取数据 4.4 步骤四:数据库返回查询结果 4.5 步骤五:把查询结果放到对应的缓存区中</p></li><li><p>SqlSessionFactory 缓存 5.1 又叫:二级缓存 5.2 有效范围:同一个 factory 内哪个 SqlSession 都可以获取 5.3 什么时候使用二级缓存: 5.3.1 当数据频繁被使用,很少被修改 5.4 使用二级缓存步骤 5.4.1 在 mapper.xml 中添加 5.4.2 如果不写 readOnly=”true”需要把实体类序列化 <code>&lt;cache readOnly=&quot;true&quot;&gt;&lt;/cache&gt;</code> 5.5 当 SqlSession 对象 close()时或 commit()时会把 SqlSession 缓存 的数据刷(flush)到 SqlSessionFactory 缓存区中</p></li></ol></div>',3),a=[o];function n(c,S){return l(),s("div",null,a)}const q=e(t,[["render",n],["__file","mybatis_f_rcode.html.vue"]]);export{q as default};
