import{_ as e,p as i,q as l,a1 as s}from"./framework-d81ad7e5.js";const t={},a=s('<h3 id="操作string类型" tabindex="-1"><a class="header-anchor" href="#操作string类型" aria-hidden="true">#</a> 操作String类型</h3><p>String 数据结构是简单的key-value类型，value其实不仅是String，也可以是数字，是包含很多种类型的特殊类型，并 且是二进制安全的。比如序列化的对象进行存储，比如一张图片进行二进制存储，比如一个简单的字符串,数值等等。</p><p>设值： <code>set name zhangsan </code>(说明：多次设置name会覆盖) 命令： <code>setnx key1 value1</code>： (not exist) 如果key1不存在，则设值 并返回1。如果key1存在，则不设值并返回0； <code>setex key1 10 lx</code> :(expired) 设置key1的值为lx，过期时间为10秒，10秒后key1清除（key也清除） <code>setrange string range value</code> 替换字符串</p><ul><li>取值: <code>get key</code></li><li>删值： <code>del keys</code></li><li>批量写： <code>mset k1 v1 k2 v2 ...</code> 一次性写入多个值</li><li>批量读： <code>mget k1 k2 k3</code> 一次性设值和读取（返回旧值，写上新值）:getset name lx 数值类型自增减：incr key，decr key 注意这些 key 对应的必须是数字类型字符串,否则会出错,自增或者自减1 自增或自减指定长度 incrby key increment，decrby key increment 对应的 key 自增或者自减increment值 字符串尾部拼接：append key value 向 key 对应的字符串尾部追加 value 字符串长度：strlen key</li></ul><hr><h3 id="hash类型" tabindex="-1"><a class="header-anchor" href="#hash类型" aria-hidden="true">#</a> Hash类型</h3><p>Hash类型是String类型的field和value的映射表，或者说是一个String集合。它特别适合存储对象，相比较而言，将一个 对象类型存储在Hash类型要存储在String类型里占用更少的内存空间，并方整个对象的存取。</p><ul><li>设值：hset hashname field value（hset是设值命令，hashname是集合名字，field是字段名，value是值）</li><li>取值：hget hashname field</li><li>批量设置：hmset hashname field1 value1 field2 value2 ….</li><li>批量取值：hmget hashname field1 field2 ...</li></ul><ul><li>hsetnx key field value：和setnx大同小异</li><li>HINCRBY key field increment：指定字段增加指定值</li><li>hexists key field：指定 key 中是否存在指定 field，如果存在返回1，不存在返回0</li><li>hdel key field 删除指定key的hash的field</li><li>hlen：返回hash集合里的所有的键数量(size)</li><li>hkeys key：返回hash里所有的field</li><li>hvals key：返回hash的所有field 对应的 value</li><li>hgetall key：返回hash里所有的field和value</li></ul><h3 id="list类型" tabindex="-1"><a class="header-anchor" href="#list类型" aria-hidden="true">#</a> List类型</h3><p>List类型是一个链表结构的集合，其主要功能有push、pop、获取元素等。更详细的说，List类型是一个双端链表的节后， 我们可以通过相关的操作进行集合的头部或者尾部添加和删除元素，List的设计非常简单精巧，即可以作为栈，又可以作为队 列，满足绝大多数的需求。</p><ul><li>lpush key1 value1 value2...：从头部加入元素（栈，先进后出）</li><li>rpush key1 value1 value2 ...：从尾部加入元素（队列，先进先出）</li><li>linsert key BEFORE|AFTER pivot value</li><li>该命令首先会在列表中从左到右查找值为pivot的元素，然后根据第二个参数是BEFORE还是AFTER来决定将value插入 到该元素的前面还是后面</li><li>lrange key start stop:获取指定索引内的所有元素,只可从左到右 0 -1代表所有</li><li>lset key index value：将key 集合中 index下表的元素替换掉</li><li>lrem key count value</li><li>lrem命令会删除列表中前count个值为value的元素，返回实际删除的元素个数。根据count值的不同，该命令的执行方式会 有所不同： <ul><li><p>当count&gt;0时， LREM会从列表左边开始删除。</p></li><li><p>当count&lt;0时， LREM会从列表后边开始删除。</p></li><li><p>当count=0时， LREM删除所有值为value的元素。</p><p>ltrim key start stop：保留制定key的值范围内的数据, 其他数据会删掉, 和 lrange 一样的参数范围 lpop key：从list的头部删除元素，并返回删除元素。 rpop key：从list的尾部删除元素，并返回删除元素 rpoplpush list1 list2：从list1尾部删除元素，并将被移除的元素添加到list2的头部，返回被移除的元素，可以实现MQ llen key：返回元素个数 lindex key index：返回名称为key的list中index位置的元素</p></li></ul></li></ul><h3 id="set类型" tabindex="-1"><a class="header-anchor" href="#set类型" aria-hidden="true">#</a> Set类型</h3><p>set集合是string类型的无序集合，set是通过hashtable实现的，对集合我们可以取交集、并集、差集</p><ul><li>SADD key member [member ...]：向名称为key的set中添加元素，set集合不允许重复元素。</li><li>SMEMBERS key：查看set集合中的元素。</li><li>SREM key member [member ...]：删除set集合的元素</li><li>SPOP key：随机删除指定set中的一个内容并将删除的内容返回</li><li>SDIFF key [key ...]：差集运算,返回在第一个set 中存在,第二个set 中不存在的内容</li><li>sdiffstore set4 set2 set3 将set2 set3不同元素的比较结果保存到set4中</li><li>SINTER key [key ...]：取交集,集合重复的数据</li><li>sinterstore：set3 set1 set2取交集后保存到 set3</li><li>SUNION key [key ...]:取并集,因为是 set 所以相同部分只会取一次</li><li>sunionstore set3 set1 set2：取并集后保存到 set1</li><li>smove set1 set2：从一个set集合移动到另一个set集合里</li><li>SCARD key：查看集合里的元素个数</li><li>SISMEMBER key member：判断某个元素是否为集合中的元素，是，返回1。不是，返回0。</li><li>srandmember key：随机返回一个元素</li></ul><h3 id="zset类型" tabindex="-1"><a class="header-anchor" href="#zset类型" aria-hidden="true">#</a> Zset类型</h3><p>有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。 redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p>ZADD key score member [score member ...]： score 是分, member 是内容, score 必须是数字,向有序集合 中添加一个元素，该元素如果存在则更新顺序，如果分值相同元素不同会同时存在两个元素。 ZSCORE key member 获取指定key 中指定内容的分数 ZREM key member [member ...] ：删除zset名称key中的member元素 ZRANGE key start stop [WITHSCORES] 获得排名在某个范围的元素列表,照元素分数从小到大的顺序返回索引从start 到stop之间的所有元素（包含两端的元素）[WITHSCORES]为可选项,代表是否在结果中显示分数 ZREVRANGE key start stop [WITHSCORES] 照元素分数从大到小的顺序返回索引从start到stop之间的所有元 素（包含两端的元素） ZRANK key member 返回有序集合中指定成员的索引（从小到大排序） ZREVRANK key member 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序 ZCARD key 返回集合里所有元素的个数 ZCOUNT key min max 返回集合中score在给定区间中的数量 zincrby key increment member： 有序集合中对指定成员的分数加上增量 increment zrangebyscore key min max [WITHSCORES] [LIMIT offset count] ：通过分数返回有序集合指定区间内的成员 min max 代表分数范围 ,offset 代表偏移量, count 代表获取多少个,类似于数据库 zremrangebyrank key start stop ：移除有序集合中给定的排名区间的所有成员 zremrangebyscore key min max：移除有序集合中给定的分数区间的所有成员 ZINCRBY key increment member 增加memeber元素的分数increment，返回值是更改后的分数</p><h3 id="hyperloglog" tabindex="-1"><a class="header-anchor" href="#hyperloglog" aria-hidden="true">#</a> HyperLogLog</h3><p><strong>Redis 在 2.8.9 版本添加了 HyperLogLog 结构。</strong><strong>Redis HyperLogLog</strong> 是用来做基数统计的算法，<strong>HyperLogLog</strong> 的优点是，在输入元素的数量或者体积非常非常大时，计 算基数所需的空间总是固定的、并且是很小的。</p><h2 id="高级命令" tabindex="-1"><a class="header-anchor" href="#高级命令" aria-hidden="true">#</a> 高级命令</h2><h3 id="常用命令" tabindex="-1"><a class="header-anchor" href="#常用命令" aria-hidden="true">#</a> 常用命令</h3><p>keys * : 返回满足的所有键 ,可以模糊匹配 比如 keys abc* 代表 abc 开头的 key exists key ：是否存在指定的key，存在返回1，不存在返回0 expire key second：设置某个key的过期时间 时间为秒 del key:删除某个key ttl key：查看剩余时间,当key不存在时，返回 -2;存在但没有设置剩余生存时间时，返回 -1,否则，以秒为单位，返回 key 的剩余生存时间。 persist key：取消过去时间 PEXPIRE key milliseconds 修改key 的过期时间为毫秒 select : 选择数据库 数据库为0-15（默认一共16个数据库） s 设计成多个数据库实际上是为了数据库安全和备份 move key dbindex ： 将当前数据中的key转移到其他数据库 randomkey：随机返回一个key rename key key2：重命名key echo：打印命令 dbsize：查看数据库的key数量 info：查看数据库信息 config get * 实时传储收到的请求，返回相关的配置 flushdb ：清空当前数据库 flushall ：清空所有数据库</p><h3 id="redis事务" tabindex="-1"><a class="header-anchor" href="#redis事务" aria-hidden="true">#</a> Redis事务</h3><p>Redis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p><div class="custom-container tip"><p class="custom-container-title">TIP</p><ul><li>事务是一个单独的隔离操作：</li><li>事务中的所有命令都会序列化、按顺序地执行。</li><li>事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li><li>事务是一个原子操作：</li><li>事务中的命令要么全部被执行，要么全部都不执行</li></ul></div><p>** MULTI 开启事务 EXEC 执行事务 DISCARD 取消事务 WATCH key 监听某个 key的值是否发生变化,如果发生变化, watch 之后的操作会失败 **</p><h3 id="持久化功能" tabindex="-1"><a class="header-anchor" href="#持久化功能" aria-hidden="true">#</a> 持久化功能</h3><p>Redis为了内部数据的安全考虑，会把本身的数据以文件形式保存到硬盘中一份，在服务器重启之后会把硬盘的数据恢复到内存（redis）的里边。 数据保存到硬盘的过程就称为“持久化”效果。</p><ol><li>snap shotting快照持久化 该持久化默认开启，一次性把redis中全部的数据保存一份存储到硬盘中，如果数据非常多（10-20G）就不适合频繁进行该持久化操作。 默认的文件名为：dump.rdb 快照持久化的备份频率： save 900 1 #900秒内如果超过1个key被修改，则发起快照保存 save 300 10 #300秒超过10个key被修改，发起快照保存 save 60 10000 #60秒超过10000个key被修改，发起快照保存 1.1手动发起快照持久化 bgsave指令</li><li>append only file（AOF持久化） 本质：把用户执行的每个“写”指令（添加、删除、修改）都备份到文件中，还原数据的时候就是执行具体写指令而已。 开启AOF持久化（会清空redis内部的数据）： 默认没有开启 2.1 为aof备份文件做优化处理 对appendonly.aof文件内容做优化压缩处理（例如多个incr指令变为一个set指令）</li></ol><p>Redis的持久化相关指令： ·gbsave异步保存数据到磁盘（快照保存） ·lastsave返回上次成功保存到磁盘的unix时间戳 ·shutdown同步保存到服务器并关闭redis服务器 ·gbrewriteaof当日志文件过长时优化AOF日志文件存储</p><h3 id="主从模式" tabindex="-1"><a class="header-anchor" href="#主从模式" aria-hidden="true">#</a> 主从模式</h3><p>为了降低每个redis服务器的负载，可以多设置几个，并做主从模式，一个服务器负责“写”数据，其他服务器负责“读”数据，主服务器数据会“自动”同步给从服务器。 配置redis.conf文件，之后文件保存退出，杀死旧的redis进程，启动新的redis进程。 Slave服务器默认禁止写操作。</p>',33),r=[a];function n(d,h){return i(),l("div",null,r)}const y=e(t,[["render",n],["__file","redis_tmlt.html.vue"]]);export{y as default};
