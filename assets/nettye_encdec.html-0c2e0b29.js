import{_ as e,p as n,q as l,a1 as a}from"./framework-d81ad7e5.js";const t="/assets/bound-13428700.png",d={},r=a('<h3 id="netty编解码器和handler的调用机制" tabindex="-1"><a class="header-anchor" href="#netty编解码器和handler的调用机制" aria-hidden="true">#</a> Netty编解码器和handler的调用机制</h3><p><img src="'+t+'" alt="alt"></p><ol><li><p>netty的组件设计：Netty的主要组件有Channel、EventLoop、ChannelFuture、ChannelHandler、ChannelPipe等</p></li><li><p>ChannelHandler充当了处理入站和出站数据的应用程序逻辑的容器。</p></li><li><p>例如，实现ChannelInboundHandler接口（或ChannelInboundHandlerAdapter），你就可以接收入站事件和数据，这些数据会被业务逻辑处理。</p></li><li><p>当要给客户端发送响应时，也可以从ChannelInboundHandler冲刷数据。</p></li><li><p>业务逻辑通常写在一个或者多个ChannelInboundHandler中。ChannelOutboundHandler原理一样，只不过它是用来处理出站数据的</p></li><li><p>ChannelPipeline提供了ChannelHandler链的容器。以客户端应用程序为例，如果事件的运动方向是从客户端到服务端的，那么我们称这些事件为出站的，即客户端发送给服务端的数据会通过pipeline中的一系列ChannelOutboundHandler，并被这些Handler处理，反之则称为入站的</p></li><li><p>编写网络应用程序时，因为数据在网络中传输的都是二进制字节码数据，在发送数据时就需要编码，接收数据时就需要解码 [示意图]</p></li><li><p>codec(编解码器) 的组成部分有两个：decoder(解码器)和 encoder(编码器)。encoder 负责把业务数据转换成字节码数据，decoder 负责把字节码数据转换成业务数据</p></li></ol><p>Netty 自身提供了一些 codec(编解码器)</p><p>Netty 提供的编码器 StringEncoder，对字符串数据进行编码 ObjectEncoder，对 Java 对象进行编码</p><p>Netty 提供的解码器 StringDecoder, 对字符串数据进行解码 ObjectDecoder，对 Java 对象进行解码</p><p>Netty 本身自带的 ObjectDecoder 和 ObjectEncoder 可以用来实现 POJO 对象或各种业务对象的编码和解码，底层使用的仍是 Java 序列化技术 , 而Java 序列化技术本身效率就不高，存在如下问题 无法跨语言 序列化后的体积太大，是二进制编码的 5 倍多。 序列化性能太低</p><ul><li><p>当Netty发送或者接受一个消息的时候，就将会发生一次数据转换。入站消息会被解码：从字节转换为另一种格式（比如java对象）；如果是出站消息，它会被编码成字节。</p></li><li><p>Netty提供一系列实用的编解码器，他们都实现了ChannelInboundHadnler或者ChannelOutboundHandler接口。在这些类中，channelRead方法已经被重写了。以入站为例，对于每个从入站Channel读取的消息，这个方法会被调用。随后，它将调用由解码器所提供的decode()方法进行解码，并将已经解码的字节转发给ChannelPipeline中的下一个ChannelInboundHandler。</p></li></ul><h3 id="其它解码器" tabindex="-1"><a class="header-anchor" href="#其它解码器" aria-hidden="true">#</a> 其它解码器</h3><ul><li><p>LineBasedFrameDecoder：这个类在Netty内部也有使用，它使用行尾控制字符（\\n或者\\r\\n）作为分隔符来解析数据。</p></li><li><p>DelimiterBasedFrameDecoder：使用自定义的特殊字符作为消息的分隔符。</p></li><li><p>HttpObjectDecoder：一个HTTP数据的解码器</p></li><li><p>LengthFieldBasedFrameDecoder：通过指定长度来标识整包消息，这样就可以自动的处理黏包和半包消息。</p></li></ul>',10),i=[r];function p(c,o){return n(),l("div",null,i)}const s=e(d,[["render",p],["__file","nettye_encdec.html.vue"]]);export{s as default};
