import{_ as l,p as e,q as i,a1 as t}from"./framework-d81ad7e5.js";const r={},o=t("<ol><li>Spring WebFlux 是一个异步非阻塞式 IO 模型，通过少量的容器线程就可以支撑大量的并发访问，</li><li>所以 Spring WebFlux 可以有效提升系统的吞吐量和伸缩性，特别是在一些 IO 密集型应用中，</li><li>Spring WebFlux 的优势明显。例如微服务网关 Spring Cloud Gateway 就使用了 WebFlux，</li><li>这样可以有效提升网管对下游服务的吞吐量。</li><li><strong>不过需要注意的是，接口的响应时间并不会因为使用了 WebFlux 而缩短，</strong> 服务端的处理结果还是得由 worker 线程处理完成之后再返回给前端。</li><li>WebFlux 底层使用 Netty 容器，这点也和我们传统的 SpringMVC 不一样，不过默认端口都是 8080。</li><li>Reactor 是一个用于 JVM 的完全非阻塞的响应式编程框架，具备高效的需求管理，可以很好的处理 “backpressure”，它可以直接与 Java8 的函数式 API 直接集成，例如 CompletableFuture、各种 Stream 等。</li><li>Reactor 还提供了异步序列 API Flux（用于 N 个元素）和 Mono（用于 0|1 个元素），并完全遵循和实现了“响应式扩展规范”（Reactive Extensions Specification）。</li></ol><ul><li>base Spring 5</li><li>Mono：实现发布者 Publisher，并返回 0 或 1 个元素。</li><li>Flux：实现发布者 Publisher，并返回 N 个元素。</li><li>webFlux 核心控制器 <strong>DispatcherHandler</strong> 实现接口 <strong>WebHandler</strong></li></ul>",2),n=[o];function a(s,u){return e(),i("div",null,n)}const _=l(r,[["render",a],["__file","webflux_a.html.vue"]]);export{_ as default};
