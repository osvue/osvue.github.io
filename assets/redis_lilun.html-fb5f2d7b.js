import{_ as l,p as i,q as s,a1 as t}from"./framework-d81ad7e5.js";const e={},o=t('<ul><li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis不仅仅支持简单的<strong>key-value</strong>类型的数据，同时还提供<strong>list，set，zset，hash</strong>等数据结构的存储。</li><li>Redis支持数据的备份，即<strong>master-slave</strong>模式的数据备份。</li></ul><ul><li><strong>原子 – Redis</strong>的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。（事务）</li></ul><ol><li>缓存和数据库双写一致性问题</li></ol><ul><li>一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。 <ul><li>数据库和缓存双写，就必然会存在不一致的问题。答这个问题，先明白一个前提。</li><li>就是如果对数据有强一致性要求，不能放缓存。我们所做的一切，只能保证最终一致性。</li><li>另外，我们所做的方案其实从根本上来说，只能说降低不一致发生的概率，无法完全避免。</li><li>因此，有强一致性要求的数据，不能放缓存。</li></ul></li><li>回答:《分布式之数据库和缓存双写一致性方案解析》给出了详细的分析，在这里简单的说一说。 <ul><li>首先，采取正确更新策略，</li><li><strong>先更新数据库，再删缓存。</strong> 其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。</li></ul></li></ul><ol start="2"><li>缓存雪崩问题、缓存穿透</li></ol><ul><li>这两个问题，一般中小型传统软件企业，很难碰到这个问题。如果有大并发的项目，日流量有KW级上。这两个问题一定要 深刻考虑。</li></ul><ul><li>缓存穿透，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。 (四)缓存的并发竞争问题</li></ul>',7),r=[o];function n(u,_){return i(),s("div",null,r)}const c=l(e,[["render",n],["__file","redis_lilun.html.vue"]]);export{c as default};
