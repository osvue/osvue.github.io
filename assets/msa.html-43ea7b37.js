import{_ as i,p as e,q as a,a1 as l}from"./framework-d81ad7e5.js";const r={},h=l('<h2 id="技术重点" tabindex="-1"><a class="header-anchor" href="#技术重点" aria-hidden="true">#</a> 技术重点</h2><ul><li>介绍让人能听懂</li><li>这个技术是干什么？</li><li>这个技术解决了什么问题？</li><li>这个技术如何解决了这个问题？</li><li>这个技术有什么弊端？</li><li>这个技术和其他有什么差别（为什么要选他）</li></ul><h2 id="list" tabindex="-1"><a class="header-anchor" href="#list" aria-hidden="true">#</a> List</h2><ul><li>干什么：数组结构的单列集合实现 Collction</li><li>解决什么问题：快速查询数据</li><li>如何解决：数组结构</li><li>缺点： 增删慢</li><li>对比: 有序,set 无序</li><li><h2 id="map" tabindex="-1"><a class="header-anchor" href="#map" aria-hidden="true">#</a> Map</h2></li><li>干什么：KV存储的,</li><li>解决什么问题：结合数组和链表优点</li><li>如何解决：</li><li>缺点:</li><li>对比:</li><li><h2 id="队列-queue-有界队列-无界队列" tabindex="-1"><a class="header-anchor" href="#队列-queue-有界队列-无界队列" aria-hidden="true">#</a> 队列 queue 有界队列,无界队列</h2></li><li>是什么：一个队列就是一个先入先出（FIFO）的数据结构,Queue接口与List、Set同一级别，都是继承了Collection接口。LinkedList实现了Deque接 口。</li><li><h3 id="阻塞queue" tabindex="-1"><a class="header-anchor" href="#阻塞queue" aria-hidden="true">#</a> 阻塞queue</h3></li></ul><blockquote><ul><li>实现阻塞接口的： 　　java.util.concurrent 中加入了 BlockingQueue 接口和五个阻塞队列类。它实质上就是一种带有一点扭曲的 FIFO 数据结构。不是立即从队列中添加或者删除元素，线程执行操作阻塞，直到有空间或者元素可用。 五个队列所提供的各有不同： 　　* ArrayBlockingQueue ：一个由数组支持的有界队列。 　　* LinkedBlockingQueue ：一个由链接节点支持的可选有界队列。 　　* PriorityBlockingQueue ：一个由优先级堆支持的无界优先级队列。 　　* DelayQueue ：一个由优先级堆支持的、基于时间的调度队列。 　　* SynchronousQueue ：一个利用 BlockingQueue 接口的简单聚集（rendezvous）机制。</li></ul></blockquote><ul><li><h3 id="非阻塞queue" tabindex="-1"><a class="header-anchor" href="#非阻塞queue" aria-hidden="true">#</a> 非阻塞queue</h3></li><li><p>ConcurrentLinkedQueue 是基于链接节点的、线程安全的队列。并发访问不需要同步。因为它在队列的尾部添加元素并从头部删除它们，所以只要不需要知道队列的大 小，　　　　 　　ConcurrentLinkedQueue 对公共集合的共享访问就可以工作得很好。收集关于队列大小的信息会很慢，需要遍历队列</p></li><li><p>解决什么问题：线程池应用广泛</p></li><li><p>如何解决：</p></li><li><p>缺点:</p></li><li><p>对比:</p></li><li><h2 id="多线程" tabindex="-1"><a class="header-anchor" href="#多线程" aria-hidden="true">#</a> 多线程</h2></li><li><h2 id="反射" tabindex="-1"><a class="header-anchor" href="#反射" aria-hidden="true">#</a> 反射</h2></li><li><p>动态加载运行时的类</p></li><li><h2 id="内存结构" tabindex="-1"><a class="header-anchor" href="#内存结构" aria-hidden="true">#</a> 内存结构</h2></li><li><h2 id="垃圾回收" tabindex="-1"><a class="header-anchor" href="#垃圾回收" aria-hidden="true">#</a> 垃圾回收</h2></li><li><p>干什么：</p></li><li><p>解决什么问题：</p></li><li><p>如何解决：</p></li><li><p>缺点:</p></li><li><p>对比:</p></li><li><h2 id="项目规模" tabindex="-1"><a class="header-anchor" href="#项目规模" aria-hidden="true">#</a> 项目规模</h2></li><li></li><li><h2 id="web层上限" tabindex="-1"><a class="header-anchor" href="#web层上限" aria-hidden="true">#</a> web层上限</h2></li><li><p>前台访问层Nginx</p></li><li></li><li><h2 id="数据库上限" tabindex="-1"><a class="header-anchor" href="#数据库上限" aria-hidden="true">#</a> 数据库上限</h2></li><li></li><li><h2 id="常见配置" tabindex="-1"><a class="header-anchor" href="#常见配置" aria-hidden="true">#</a> 常见配置</h2></li><li></li><li><h2 id="并发多少" tabindex="-1"><a class="header-anchor" href="#并发多少" aria-hidden="true">#</a> 并发多少</h2></li><li></li><li><h2 id="缓存" tabindex="-1"><a class="header-anchor" href="#缓存" aria-hidden="true">#</a> 缓存</h2></li><li><p>redis keyvalue 存储的键值对;</p></li><li><p><strong>mongoDB</strong></p></li><li><h2 id="队列-中间件" tabindex="-1"><a class="header-anchor" href="#队列-中间件" aria-hidden="true">#</a> 队列(中间件)</h2></li><li><h2 id="cloud" tabindex="-1"><a class="header-anchor" href="#cloud" aria-hidden="true">#</a> cloud</h2></li><li><h2 id="优化" tabindex="-1"><a class="header-anchor" href="#优化" aria-hidden="true">#</a> 优化</h2></li><li><h2 id="设计" tabindex="-1"><a class="header-anchor" href="#设计" aria-hidden="true">#</a> 设计</h2></li></ul>',6),d=[h];function n(u,t){return e(),a("div",null,d)}const s=i(r,[["render",n],["__file","msa.html.vue"]]);export{s as default};
