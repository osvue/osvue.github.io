import{_ as e,p as a,q as r,a1 as t}from"./framework-d81ad7e5.js";const c="/assets/zc-eb704705.png",o={},i=t('<h2 id="using-multiple-reactors" tabindex="-1"><a class="header-anchor" href="#using-multiple-reactors" aria-hidden="true">#</a> Using Multiple Reactors</h2><p>多线程模型 <img src="'+c+'" alt="alt"></p><h3 id="流程说明" tabindex="-1"><a class="header-anchor" href="#流程说明" aria-hidden="true">#</a> 流程说明</h3><ol><li>Reactor主线程 MainReactor 对象通过select 监听连接事件, 收到事件后，通过Acceptor 处理连接事件</li><li>当 Acceptor 处理连接事件后，MainReactor 将连接分配给SubReactor</li><li>subreactor 将连接加入到连接队列进行监听,并创建handler进行各种事件处理</li><li>当有新事件发生时， subreactor 就会调用对应的handler处理</li><li>handler 通过read 读取数据，分发给后面的worker 线程处理</li><li>worker 线程池分配独立的worker 线程进行业务处理，并返回结果</li><li>handler 收到响应的结果后，再通过send 将结果返回给client</li><li>Reactor 主线程可以对应多个Reactor 子线程, 即MainRecator 可以关联多个SubReactor</li></ol><p>优点：父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理。 优点：父线程与子线程的数据交互简单，Reactor 主线程只需要把新连接传给子线程，子线程无需返回数据。 缺点：编程复杂度较高</p><blockquote><p>结合实例：这种模型在许多项目中广泛使用，包括 Nginx 主从 Reactor 多进程模型，Memcached 主从多线程，Netty 主从多线程模型的支持</p></blockquote><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>单 Reactor 单线程，前台接待员和服务员是同一个人，全程为顾客服 单 Reactor 多线程，1 个前台接待员，多个服务员，接待员只负责接待 主从 Reactor 多线程，多个前台接待员，多个服务生</p>',8),l=[i];function n(s,d){return a(),r("div",null,l)}const p=e(o,[["render",n],["__file","reactor_d.html.vue"]]);export{p as default};
