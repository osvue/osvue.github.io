import{_ as n,p as a,q as s,a1 as e}from"./framework-d81ad7e5.js";const t="/assets/pipe-dd53243d.png",p="/assets/eventloop-6c3112d1.png",o={},l=e(`<h3 id="bootstrap" tabindex="-1"><a class="header-anchor" href="#bootstrap" aria-hidden="true">#</a> Bootstrap</h3><blockquote><p>Bootstrap 意思是引导，一个 Netty 应用通常由一个 Bootstrap 开始，主要作用是配置整个 Netty 程序，串联各个组件，Netty 中 Bootstrap 类是客户端程序的启动引导类，ServerBootstrap 是服务端启动引导类</p></blockquote><ul><li>常见的方法有</li></ul><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ServerBootstrap</span> <span class="token function">group</span><span class="token punctuation">(</span><span class="token class-name">EventLoopGroup</span> parentGroup<span class="token punctuation">,</span> <span class="token class-name">EventLoopGroup</span> childGroup<span class="token punctuation">)</span>，该方法用于服务器端，用来设置两个 <span class="token class-name">EventLoop</span>
<span class="token keyword">public</span> <span class="token class-name">B</span> <span class="token function">group</span><span class="token punctuation">(</span><span class="token class-name">EventLoopGroup</span> group<span class="token punctuation">)</span> ，该方法用于客户端，用来设置一个 <span class="token class-name">EventLoop</span>
<span class="token keyword">public</span> <span class="token class-name">B</span> <span class="token function">channel</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">C</span><span class="token punctuation">&gt;</span></span> channelClass<span class="token punctuation">)</span>，该方法用来设置一个服务器端的通道实现
<span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">B</span> <span class="token function">option</span><span class="token punctuation">(</span><span class="token class-name">ChannelOption</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> option<span class="token punctuation">,</span> <span class="token class-name">T</span> value<span class="token punctuation">)</span>，用来给 <span class="token class-name">ServerChannel</span> 添加配置
<span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">ServerBootstrap</span> <span class="token function">childOption</span><span class="token punctuation">(</span><span class="token class-name">ChannelOption</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> childOption<span class="token punctuation">,</span> <span class="token class-name">T</span> value<span class="token punctuation">)</span>，用来给接收到的通道添加配置
<span class="token keyword">public</span> <span class="token class-name">ServerBootstrap</span> <span class="token function">childHandler</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandler</span> childHandler<span class="token punctuation">)</span>，该方法用来设置业务处理类（自定义的 handler）
<span class="token keyword">public</span> <span class="token class-name">ChannelFuture</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">int</span> inetPort<span class="token punctuation">)</span> ，该方法用于服务器端，用来设置占用的端口号
<span class="token keyword">public</span> <span class="token class-name">ChannelFuture</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token class-name">String</span> inetHost<span class="token punctuation">,</span> <span class="token keyword">int</span> inetPort<span class="token punctuation">)</span> ，该方法用于客户端，用来连接服务器端
</code></pre></div><h3 id="future、channelfuture" tabindex="-1"><a class="header-anchor" href="#future、channelfuture" aria-hidden="true">#</a> Future、ChannelFuture</h3><ol><li>Netty 中所有的 IO 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 Future 和 ChannelFutures，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件</li></ol><ul><li>常见的方法有</li></ul><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token class-name">Channel</span> <span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>，返回当前正在进行 <span class="token constant">IO</span> 操作的通道
<span class="token class-name">ChannelFuture</span> <span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span>，等待异步操作执行完毕
</code></pre></div><h3 id="channel" tabindex="-1"><a class="header-anchor" href="#channel" aria-hidden="true">#</a> Channel</h3><ol><li>Netty 网络通信的组件，能够用于执行网络 I/O 操作。</li><li>通过Channel 可获得当前网络连接的通道的状态</li><li>通过Channel 可获得 网络连接的配置参数 （例如接收缓冲区大小）</li><li>Channel 提供异步的网络 I/O 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 I/O 调用都将立即返回，并且不保证在调用结束时所请求的 I/O 操作已完成</li><li>调用立即返回一个 ChannelFuture 实例，通过注册监听器到 ChannelFuture 上，可以 I/O 操作成功、失败或取消时回调通知调用方</li><li>支持关联 I/O 操作与对应的处理程序</li><li>不同协议、不同的阻塞类型的连接都有不同的 Channel 类型与之对应，常用的 Channel 类型:</li></ol><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token class-name">NioSocketChannel</span>，异步的客户端 <span class="token constant">TCP</span> <span class="token class-name">Socket</span> 连接。
<span class="token class-name">NioServerSocketChannel</span>，异步的服务器端 <span class="token constant">TCP</span> <span class="token class-name">Socket</span> 连接。
<span class="token class-name">NioDatagramChannel</span>，异步的 <span class="token constant">UDP</span> 连接。
<span class="token class-name">NioSctpChannel</span>，异步的客户端 <span class="token class-name">Sctp</span> 连接。
<span class="token class-name">NioSctpServerChannel</span>，异步的 <span class="token class-name">Sctp</span> 服务器端连接，这些通道涵盖了 <span class="token constant">UDP</span> 和 <span class="token constant">TCP</span> 网络 <span class="token constant">IO</span> 以及文件 <span class="token constant">IO</span>。
</code></pre></div><h3 id="selector" tabindex="-1"><a class="header-anchor" href="#selector" aria-hidden="true">#</a> Selector</h3><ol><li>Netty 基于 Selector 对象实现 I/O 多路复用，通过 Selector 一个线程可以监听多个连接的 Channel 事件。</li><li>当向一个 Selector 中注册 Channel 后，Selector 内部的机制就可以自动不断地查询(Select) 这些注册的 Channel 是否有已就绪的 I/O 事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多个 Channel</li></ol><h3 id="channelhandler-及其实现类" tabindex="-1"><a class="header-anchor" href="#channelhandler-及其实现类" aria-hidden="true">#</a> ChannelHandler 及其实现类</h3><ol><li>ChannelHandler 是一个接口，处理 I/O 事件或拦截 I/O 操作，并将其转发到其 ChannelPipeline(业务处理链)中的下一个处理程序。</li><li>ChannelHandler 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类</li><li>ChannelHandler 及其实现类 <ol><li>ChannelInboundHandler 用于处理入站 I/O 事件。</li><li>ChannelOutboundHandler 用于处理出站 I/O 操作。 <ol><li>//适配器 <ol><li>ChannelInboundHandlerAdapter 用于处理入站 I/O 事件。</li><li>ChannelOutboundHandlerAdapter 用于处理出站 I/O 操作。</li><li>ChannelDuplexHandler 用于处理入站和出站事件。</li></ol></li></ol></li></ol></li><li>我们经常需要自定义一个 Handler 类去继承 ChannelInboundHandlerAdapter，然后通过重写相应方法实现业务逻辑，接下来看看一般都需要重写哪些方法</li></ol><div class="language-java" data-ext="java"><pre class="language-java"><code>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ChannelInboundHandlerAdapter</span> <span class="token keyword">extends</span> <span class="token class-name">ChannelHandlerAdapter</span> <span class="token keyword">implements</span> <span class="token class-name">ChannelInboundHandler</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token class-name">ChannelInboundHandlerAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelRegistered</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>ctx<span class="token punctuation">.</span><span class="token function">fireChannelRegistered</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelUnregistered</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        ctx<span class="token punctuation">.</span><span class="token function">fireChannelUnregistered</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment">//通道就绪事件   </span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelActive</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>ctx<span class="token punctuation">.</span><span class="token function">fireChannelActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelInactive</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>ctx<span class="token punctuation">.</span><span class="token function">fireChannelInactive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>

    <span class="token comment">//通道读取数据事件 </span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelRead</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">Object</span> msg<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>ctx<span class="token punctuation">.</span><span class="token function">fireChannelRead</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>

    <span class="token comment">//数据读取完毕事件   </span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelReadComplete</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>ctx<span class="token punctuation">.</span><span class="token function">fireChannelReadComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">userEventTriggered</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">Object</span> evt<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        ctx<span class="token punctuation">.</span><span class="token function">fireUserEventTriggered</span><span class="token punctuation">(</span>evt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelWritabilityChanged</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        ctx<span class="token punctuation">.</span><span class="token function">fireChannelWritabilityChanged</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token comment">//通道发生异常事件   </span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">exceptionCaught</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">Throwable</span> cause<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        ctx<span class="token punctuation">.</span><span class="token function">fireExceptionCaught</span><span class="token punctuation">(</span>cause<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><h3 id="pipeline-和-channelpipeline" tabindex="-1"><a class="header-anchor" href="#pipeline-和-channelpipeline" aria-hidden="true">#</a> Pipeline 和 ChannelPipeline</h3><ol><li><p>ChannelPipeline 是一个 Handler 的集合，它负责处理和拦截 inbound 或者 outbound 的事件和操作，相当于一个贯穿 Netty 的链。(也可以这样理解：<strong>ChannelPipeline 是 保存 ChannelHandler 的 List</strong>，用于处理或拦截 Channel 的入站事件和出站操作)</p></li><li><p>ChannelPipeline 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 Channel 中各个的 ChannelHandler 如何相互交互</p></li><li><p>在 Netty 中每个 Channel 都有且仅有一个 ChannelPipeline 与之对应，它们的组成关系如下 <img src="`+t+`" alt="at"></p><ol><li><p>一个 Channel 包含了一个 ChannelPipeline，而 ChannelPipeline 中又维护了一个由 ChannelHandlerContext 组成的双向链表，并且每个 ChannelHandlerContext 中又关联着一个 ChannelHandler</p></li><li><p>入站事件和出站事件在一个双向链表中，入站事件会从链表 head 往后传递到最后一个入站的 handler，出站事件会从链表 tail 往前传递到最前一个出站的 handler，两种类型的 handler 互不干扰</p></li></ol></li><li><p>常用方法</p></li></ol><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token class-name">ChannelPipeline</span> <span class="token function">addFirst</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandler</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> handlers<span class="token punctuation">)</span>，把一个业务处理类（handler）添加到链中的第一个位置
<span class="token class-name">ChannelPipeline</span> <span class="token function">addLast</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandler</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> handlers<span class="token punctuation">)</span>，把一个业务处理类（handler）添加到链中的最后一个位置
</code></pre></div><h3 id="channelhandlercontext" tabindex="-1"><a class="header-anchor" href="#channelhandlercontext" aria-hidden="true">#</a> ChannelHandlerContext</h3><ol><li>保存 Channel 相关的所有上下文信息，同时关联一个 ChannelHandler 对象</li><li>即ChannelHandlerContext 中 包 含 一 个 具 体 的 事 件 处 理 器 ChannelHandler ， 同 时ChannelHandlerContext 中也绑定了对应的 pipeline 和 Channel 的信息，方便对 ChannelHandler进行调用.</li><li>常用方法</li></ol><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token class-name">ChannelFuture</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>，关闭通道
<span class="token class-name">ChannelOutboundInvoker</span> <span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span>，刷新
<span class="token class-name">ChannelFuture</span> <span class="token function">writeAndFlush</span><span class="token punctuation">(</span><span class="token class-name">Object</span> msg<span class="token punctuation">)</span> ， 将 数 据 写 到 <span class="token class-name">ChannelPipeline</span> 中 当 前
<span class="token class-name">ChannelHandler</span> 的下一个 <span class="token class-name">ChannelHandler</span> 开始处理（出站）

</code></pre></div><h3 id="channeloption" tabindex="-1"><a class="header-anchor" href="#channeloption" aria-hidden="true">#</a> ChannelOption</h3><blockquote><p>Netty 在创建 Channel 实例后,一般都需要设置 ChannelOption 参数。 ChannelOption 参数如下: <strong>ChannelOption.SO_BACKLOG</strong> 对应 TCP/IP 协议 listen 函数中的 backlog 参数，用来初始化服务器可连接队列大小。服 务端处理客户端连接请求是顺序处理的，所以同一时间只能处理一个客户端连接。多个客户 端来的时候，服务端将不能处理的客户端连接请求放在队列中等待处理，backlog 参数指定 了队列的大小。</p></blockquote><p><strong>ChannelOption.SO_KEEPALIVE</strong> 一直保持连接活动状态</p><h3 id="eventloopgroup" tabindex="-1"><a class="header-anchor" href="#eventloopgroup" aria-hidden="true">#</a> EventLoopGroup</h3><h5 id="eventloopgroup-和其实现类-nioeventloopgroup" tabindex="-1"><a class="header-anchor" href="#eventloopgroup-和其实现类-nioeventloopgroup" aria-hidden="true">#</a> EventLoopGroup 和其实现类 NioEventLoopGroup</h5><ol><li><p>EventLoopGroup 是一组 EventLoop 的抽象，Netty 为了更好的利用多核 CPU 资源，一般会有多个 EventLoop 同时工作，每个 EventLoop 维护着一个 Selector 实例。</p></li><li><p>EventLoopGroup 提供 next 接口，可以从组里面按照一定规则获取其中一个 EventLoop来处理任务。在 Netty 服务器端编程中，我们一般都需要提供两个 EventLoopGroup，例如：BossEventLoopGroup 和 WorkerEventLoopGroup。</p></li><li><p>通常一个服务端口即一个 ServerSocketChannel对应一个Selector 和一个EventLoop线程。BossEventLoop 负责接收客户端的连接并将 SocketChannel 交给 WorkerEventLoopGroup 来进行 IO 处理，如下图所示</p></li></ol><p><img src="`+p+`" alt="alt"></p><ul><li><p>BossEventLoopGroup 通常是一个单线程的 EventLoop，EventLoop 维护着一个注册了ServerSocketChannel 的 Selector 实例BossEventLoop 不断轮询 Selector 将连接事件分离出来</p></li><li><p>通常是 OP_ACCEPT 事件，然后将接收到的 SocketChannel 交给 WorkerEventLoopGroup</p></li><li><p>WorkerEventLoopGroup 会由 next 选择其中一个 EventLoop来将这个 SocketChannel 注册到其维护的 Selector 并对其后续的 IO 事件进行处理</p></li></ul><div class="language-java" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span>，构造方法
<span class="token keyword">public</span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token punctuation">)</span>，断开连接，关闭线程
</code></pre></div><h3 id="unpooled-类" tabindex="-1"><a class="header-anchor" href="#unpooled-类" aria-hidden="true">#</a> Unpooled 类</h3><p>Netty 提供一个专门用来操作缓冲区(即Netty的数据容器)的工具类</p><p>通过给定的数据和字符编码返回一个 ByteBuf 对象（类似于 NIO 中的 ByteBuffer 但有区别）</p><p><code>public static ByteBuf copiedBuffer(CharSequence string, Charset charset)</code></p><h3 id="心跳检测" tabindex="-1"><a class="header-anchor" href="#心跳检测" aria-hidden="true">#</a> 心跳检测</h3><ul><li>参见代码</li></ul>`,37),c=[l];function i(u,k){return a(),s("div",null,c)}const d=n(o,[["render",i],["__file","nettyd_kerrel.html.vue"]]);export{d as default};
